
/*
 * Copyright (C) Niklaus F.Schen.
 */
 
Melon Developer Guide
A C framework library for simplifying development on UNIX
Melon Version 1.9.2
E-Mail: Melon-c@hotmail.com

1.Preface
Melon is a C framework library for simplifying development on UNIX.
Why is a library? Because it includes many implementations about data structures, algorithms, architectures and
many other useful components that you can choose that only use these APIs or whole framework (especially
architectures) based on your demand.
Melon has two architectures -- multithread and multiprocess.
For multithread, Melon provides a developing method which is the same as process development to build its thread
modules.

As shown in Figure 1,this is the multiprocess architecture.
                      --------------
                     |master process|
                      --------------
                             |
             --------------------------------------
            |         ..................           |
      --------------------                --------------------
     |      process 1     |              |      process N     |
      --------------------               ---------------------
     | processing logic 1 |              | processing logic N |
      --------------------                --------------------

              Figure 1. Multiprocess architecture.

And the multithread architecture shown in Figure 2.
                     --------------
                    |master process|
                     --------------
                            |
            --------------------------------------
           |         ..................           |
     --------------------                --------------------
    |      process 1     |              |      process N     |
     --------------------               ---------------------
              |                                   |
     ---------------------               ---------------------
    |     ..........      |             |     ..........      |
 -------------        ------------   -------------        -------------
| thread 11   |      | thread 1N  | | thread N1   |      | thread NN   |
 -------------        ------------   -------------        -------------
| processing  |      | processing | | processing  |      | processing  |
| logic 11    |      | logic 1N   | | logic N1    |      | logic NN    |
 -------------        ------------   -------------        -------------

              Figure 2. Multithread architecture.


2.Installation
We can install Melon following these steps:
  a) git clone https://github.com/Water-Melon/Melon.git
  b) Change directory to the Melon/.
  c) Execute shell command
         ./configure [--prefix=/...|...|--help]
         make
         sudo make install
     --prefix indicate the installation path.
     --help   show help message.
     More parameters see '--help'.

3.Types
There are some basic custom types, such as mln_u8_t, etc.
Their definitions can be found in melon-1.9.2/include/mln_types.h.

4.Interfaces
  1) String
    a) mln_string_t *mln_string_new(const char *s);
       This interface returns a mln_string_t object which is allocated by malloc(). And its content is varied by the
       argument. If the memory is not enough, NULL will be returned.

    b) mln_string_t *mln_string_dup(mln_string_t *str);
       It duplicates the argument and returns a new object.
       The new object is allocated by malloc().

    c) mln_string_t *mln_string_nDup(mln_string_t *str, mln_s32_t size);
       It is the same as mln_string_dup(), but the second argument indicates the length of the duplication.

    d) mln_string_t *mln_string_nConstDup(char *str, mln_s32_t size);
       It is the same as mln_string_nDup(), but the type of the first argument is char *.

    e) mln_string_t *mln_string_refDup(mln_string_t *str);
       This interface creates a new pointer which points to the same string contents that pointed by the argument.
       It won't free the string contents when mln_string_free() is called.

    f) mln_string_t *mln_string_refConstDup(char *s);
       It is the same as mln_string_refDup() but the argument type.

    g) void mln_string_free(mln_string_t *str);
       It is used to free mln_string_t.
       If 'str' is initialized by mln_string_refDup() or mln_string_refConstDup(), the string contents will be freed
       at the same time.

    h) int mln_string_strcmpSeq(mln_string_t *s1, mln_string_t *s2);
       e.g.
           mln_string_t a = mln_string("abcd");
           mln_string_t b = mln_string("abcedasd");
           int ret = mln_string_strcmpSeq(&a, &b);
       'ret' will be -1.

    i) int mln_string_strcmp(mln_string_t *s1, mln_string_t *s2);
       It is the same as strcmp() but the arguments' type.

    j) int mln_string_constStrcmp(mln_string_t *s1, const char *s2);
       This interface is the same as mln_string_strcmp() but the type of the second argument.

    k) int mln_string_strncmp(mln_string_t *s1, mln_string_t *s2, mln_u32_t n);
       It is the same as strncmp().

    l) int mln_string_constStrncmp(mln_string_t *s1, const char *s2, mln_u32_t n);
       It is the same as mln_string_strncmp() but the type of the second argument.

    m) int mln_string_strcasecmp(mln_string_t *s1, mln_string_t *s2);
       It is the same as strcasecmp().

    n) int mln_string_constStrcasecmp(mln_string_t *s1, const char *s2);
       It is the same as mln_string_strcasecmp() but the type of the second argument.

    o) int mln_string_constStrncasecmp(mln_string_t *s1, const char *s2, mln_u32_t n); 
       It is the same as strncasecmp().

    p) int mln_string_strncasecmp(mln_string_t *s1, mln_string_t *s2, mln_u32_t n);
       It is the same as mln_string_strncmp() but the type of the second argument.

    q) char *mln_string_strstr(mln_string_t *text, mln_string_t *pattern);
       It is the same as strstr().

    r) char *mln_string_constStrstr(mln_string_t *text, const char *pattern);
       It is the same as mln_string_strstr() but the type of the second argument.

    s) mln_string_t *mln_string_S_strstr(mln_string_t *text, mln_string_t *pattern);
       It is used to get a string which starts from the position that is matched with 'pattern'.

    t) mln_string_t *mln_string_S_constStrstr(mln_string_t *text, const char *pattern);
       The same as mln_string_S_strstr() but the type of the second argument.

    u) char *mln_string_KMPStrstr(mln_string_t *text, mln_string_t *pattern);
    v) char *mln_string_KMPConstStrstr(mln_string_t *text, const char *pattern);
    w) mln_string_t *mln_string_S_KMPStrstr(mln_string_t *text, mln_string_t *pattern);
    x) mln_string_t *mln_string_S_KMPConstStrstr(mln_string_t *text, const char *pattern);
       These four interfaces are the same as mln_string_strstr(), mln_string_constStrstr(), mln_string_S_strstr() and
       mln_string_S_constStrstr(), but implemented by KMP algorithm.

    y) mln_string_t *mln_string_slice(mln_string_t *s, const char *sep_array /*ended by \0*/);
       Slice string into several pieces.
       Slicing characters can be given by the second argument.
       This interface has a side-effect that the string buffer will be destroyed. So you can call mln_string_dup() or
       mln_string_nDup() at first.
       The return value is a vector, and its last element is NULL.

    z) void mln_string_slice_free(mln_string_t *array);
       This interface frees the vector that mln_string_slice() returned.

    aa) mln_string(s);
       This interface is used to create a string on stack. Its content is 's', and its length is sizeof(s)-1.

    ab) mln_string_set(pstring,s);
       This interface is used to set the content of 'pstring', its 'str' is 's', its length is 'strlen(s)' and its
       'is_referred' will be set 1.

    ac) mln_string_nSet(pstring,s,n);
       This interface is used to set the content of 'pstring', its 'str' is 's', its length is 'n' and its
       'is_referred' will be set 1.

    ad) mln_string_t *mln_string_pool_new(mln_alloc_t *pool, const char *s);
       This interface is the same as 'mln_string_new' but allocated from a memory pool.

    ae) void mln_string_pool_free(mln_string_t *str);
       This interface is the same as 'mln_string_free' but freed to a memory pool.

    af) mln_string_t *mln_string_strcat(mln_string_t *s1, mln_string_t *s2);
       It is the same as strcat but the data type is mln_string_t.

    ag) mln_string_t *mln_string_pool_strcat(mln_alloc_t *pool, mln_string_t *s1, mln_string_t *s2);
       It is the same as 'mln_string_strcat' but allocated by 'pool'.

  2) Hash Table
    struct mln_hash_attr {
        hash_calc_handler    hash;
        hash_cmp_handler     cmp;
        hash_free_handler    free_key;
        hash_free_handler    free_val;
        mln_u64_t            len_base;
        mln_u32_t            expandable:1;
        mln_u32_t            calc_prime:1;
    };
    typedef int  (*hash_scan_handler)(void * /*key*/, void * /*val*/, void *);
    typedef mln_u64_t  (*hash_calc_handler)(mln_hash_t *, void *);
    /*
     * cmp_handler's return value: 0 -- not matched, !0 -- matched.
     */
    typedef int  (*hash_cmp_handler) (mln_hash_t *, void *, void *);
    typedef void (*hash_free_handler)(void *);

    This structure is used to be the argument that will be passed to mln_hash_init() to initialize a hash table.
    hash -- is used to calculate and return a hash value to be the hash table index.
    cmp -- is used to compare with two hash elements' value.
    free_key and free_val -- are used to free hash element's key and value. These two pointers can be NULL.
    len_base -- is an ideal value as a seed to be passed to a prime generator to calculate the real hash table
    length if 'calc_prime' flag is set. Otherwise it only means the length of hash table.
    expandable -- is a flag to indicate whether operations
    expand hash table dynamically. 0 means no, otherwise yes.
    calc_prime -- is a flag to indicate whether a prime number should be calculated. This prime number can be the
    length or the threshold of hash table. This calculation will take maybe more than a hundred microseconds.

    a) mln_hash_t *mln_hash_init(struct mln_hash_attr *attr);
       Initialize a hash table.

    b) void mln_hash_destroy(mln_hash_t *h, mln_hash_flag_t flg);
       Destroy the hash table.
       If people set 'free_key' and (or) 'free_value' and the 'flg' is not M_HASH_F_NONE, this function will free
       hash element's key and (or) value at the same time.

    c) void *mln_hash_search(mln_hash_t *h, void *key);
       This interface searches the value data according to the key.

    d) void *mln_hash_search_iterator(mln_hash_t *h, void *key, int **ctx);
       The same as 'mln_hash_search()', and it can keep looking for the next one whose key is matched by 'key'.
       'ctx' is just an int ** variable, the initial value of '*ctx' must be NULL. If the return value is the last
       matched element in the hash table, '*ctx' will be NULL.

    e) int mln_hash_insert(mln_hash_t *h, void *key, void *val);
       It inserts a key-value into the hash table.
       If malloc() cannot allocate memory, -1 will be returned.

    f) void mln_hash_remove(mln_hash_t *h, void *key, mln_hash_flag_t flg);
       It removes a key-value from the hash table.
       If the 'free_key' and (or) 'free_value' are set and the 'flg' is not M_HASH_F_NONE, the element's key and (or)
       value will be freed at the same time.

    g) int mln_hash_scan_all(mln_hash_t *h, hash_scan_handler handler, void *udata);
       This interface is used to scan the whole table and process every key-value by the handler.
       The third argument of handler is the 'udata' provided by caller.

    h) void *mln_hash_change_value(mln_hash_t *h, void *key, void *new_value);
       This interface is used to change the value that is indicated by 'key'.
       The old value will be returned.

    i) int mln_hash_key_exist(mln_hash_t *h, void *key);
       Test whether the 'key' is existent.

    j) void mln_hash_reset(mln_hash_t *h, mln_hash_flag_t flg);
       Reset hash table. It will clear all entries in 'h'.
       If flg is not M_HASH_F_NONE and 'h->free_key' and (or) 'h->free_val' are (is) not NULL, all entries will free
       their key and (or) value at the same time.

    k) mln_hash_replace(mln_hash_t *h, void *key, void *val);
       Replace the 'key' and 'val' to an exitent k-v entry which is located by 'key'. If k-v entry is not existent, a
       new key-val entry will be created and insert into 'h'.
       Note: The second and third arguments of this function are all second rank pointer variables. For getting rid
       of the compiler's error, These two types have to be defined as void *.

  3) Fibonacci Heap
    struct mln_fheap_attr {
        fheap_cmp                cmp;
        fheap_copy               copy;
        fheap_key_free           key_free;
        void                    *min_val;
        mln_size_t               min_val_size;
    };
    cmp -- is a function pointer, its prototype is
        typedef int (*fheap_cmp)(const void *, const void *);
    The two arguments are custom structure pointers.
    And the return value is: 0 - ptr1 < ptr2, !0 - ptr1 >= ptr2.
    copy -- is also a function pointer, its prototype is
        typedef void (*fheap_copy)(void *dest, void *src);
    This function is used to copy data from 'src' to 'dest'.
    key_free -- is a function pointer to free key's value in a heap node. Its prototype is
        typedef void (*fheap_key_free)(void *);
    This pointer can be NULL.
    min_val -- is a key's value actually. This is the minimum value in the heap.
    min_val_size -- is the size of 'min_val' structure.

    a) mln_fheap_node_t* mln_fheap_node_init(mln_fheap_t *fh, void *key);
       It initializes a fibonacci heap node.
       The first argument is a pointer points to a fibonacci heap.
       The second one is a user data.
       If memory is not enough, NULL will be returned.

    b) void mln_fheap_node_destroy(mln_fheap_t *fh, mln_fheap_node_t *fn);
       It destroys a heap node and frees its system resources.
       The second argument is the pointer that mln_fheap_node_init() returned.
       If key_free isn't NULL, the key's value in the heap node will be freed.

    c) mln_fheap_t *mln_fheap_init(struct mln_fheap_attr *attr);
       It initializes and returns a fibonacci heap.

    d) void mln_fheap_destroy(mln_fheap_t *fh);
       It destroys a fibonacci heap. If 'key_free' is not NULL, the key's value in every heap node will be freed by
       the function 'key_free' at the same time.

    e) void mln_fheap_insert(mln_fheap_t *fh, mln_fheap_node_t *fn);
       This interface inserts a heap node.

    f) void mln_fheap_delete(mln_fheap_t *fh, mln_fheap_node_t *node);
       This interface removes a heap node.

    g) mln_fheap_node_t* mln_fheap_minimum(mln_fheap_t *fh);
       It retrieves a minimum heap node.
       If the heap is empty, NULL will be returned.

    h) mln_fheap_node_t* mln_fheap_extract_min(mln_fheap_t *fh);
       Extract the node whose key value is minimum in the heap.
       If the heap is empty, NULL will be returned.

    i) int mln_fheap_decrease_key(mln_fheap_t *fh, mln_fheap_node_t *node, void *key);
       It decreases the key's value of the specified node to the key.
       The type of key must be identical with the type of keys in heap nodes.
       The return value is: -1 - key error, 0 - succeed.

  4) Red-Black Tree
    struct mln_rbtree_attr {
        rbtree_cmp                cmp;
        rbtree_free_data          data_free;
    };
    cmp -- is a function pointer to compare with two RB-tree
    data. Its prototype is
        typedef int (*rbtree_cmp)(const void *, const void *);
    The type of two arguments is custom.
    And the return value is: >0 -- the first one is greater than the second; ==0 -- equal; <0 -- less.
    data_free -- is a function pointer to free data in a tree node. This pointer can be NULL. Its prototype is
        typedef void (*rbtree_free_data)(void *);

    a) mln_rbtree_node_t *mln_rbtree_node_new(mln_rbtree_t *t, void *data);
       It creates a new RB-tree node.
       The first argument is the pointer points to a RB-tree which is the one that the new node is going to be
       inserted.
       The second one is a user data pointer.
       If memory is not enough, NULL will be returned.

    b) void mln_rbtree_node_free(mln_rbtree_t *t, mln_rbtree_node_t *n);
       This function destroys RB-tree node and frees its resources.
       If RB-tree's 'data_free' is not NULL, the user data in the node will be freed by calling function data_free().

    c) mln_rbtree_t *mln_rbtree_init(struct mln_rbtree_attr *attr);
       It initializes an RB-tree.
       If memory is not enough, NULL will be returned.

    d) void mln_rbtree_destroy(mln_rbtree_t *t);
       It destroys an RB-tree.
       If 'data_free' is not NULL, all user data in the whole tree will be freed.

    e) void mln_rbtree_insert(mln_rbtree_t *t, mln_rbtree_node_t *n);
       It inserts an RB-tree node into a tree.

    f) void mln_rbtree_delete(mln_rbtree_t *t, mln_rbtree_node_t *n);
       It removes an RB-tree node from a tree.

    g) mln_rbtree_node_t* mln_rbtree_successor(mln_rbtree_t *t, mln_rbtree_node_t *n);
    It finds n's successor.
    If nothing can be found, &(t->nil) will be returned.
    This return value is the address of tree's variable 'nil', we can use mln_rbtree_null() to test it.

    h) mln_rbtree_node_t* mln_rbtree_search(mln_rbtree_t *t, mln_rbtree_node_t *root, const void *key);
       It searches an RB-tree node whose key is equal to the 'key'.
       The routine will start from 'root'. If nothing can be found, &(t->nil) will be returned.

    i) mln_rbtree_node_t* mln_rbtree_min(mln_rbtree_t *t);
       It returns the node whose user data is minimum in a tree.
       If the tree is empty, &(t->nil) will be returned.

    j) mln_rbtree_null(ptr,ptree);
       This function is used to test the return value of most rbtree interfaces.
       If function returns !0, the 'ptr' is pointing to the address of ptree's 'nil'.
       Otherwise, the data that is pointed by 'ptr' is valid.

    k) int mln_rbtree_scan_all(mln_rbtree_t *t, rbtree_act act, void *udata);
       This function is used to scan all rbtree nodes and process them by the callback function 'act'.
       t -- is a rbtree pointer.
       act -- is a callback function which is defined by the caller. Its prototype is
           typedef int (*rbtree_act)(mln_rbtree_node_t *node, void *rn_data, void *udata);
       The first argument is the rbtree node. Second one is the data of rbtree node. And the last one is an user
       data passed by the third argument of mln_rbtree_scan_all().

  5) Path
    a) char *mln_path(void);
       Depending on the parameter of shell script 'install', the installation path can be specified.
       We have to get the absolute path because some components need it.

  6) Prime number Generator
    a) mln_u32_t mln_prime_calc(mln_u32_t n);
       It returns a prime number which is equal to or greater than n.

  7) Lock
    The lock that we discuss here is a portable spin lock.

    a) MLN_LOCK_INIT(lock_ptr)
       It initializes a spin lock.
       The argument is a lock pointer.
       The return value is an integer, 0 means OK, otherwise the return value is equivalent to the error number.

    b) MLN_LOCK_DESTROY(lock_ptr)
       It destroys a spin lock.
       The return value is an integer, 0 means OK, otherwise the return value is equivalent to the error number.

    c) MLN_LOCK(lock_ptr)
       This interface triggers a lock.

    d) MLN_TRYLOCK(lock_ptr)
       This interface tries to lock. When it fails, !0 will be returned. Otherwise 0.

    e) MLN_UNLOCK(lock_ptr)
       This interface releases the lock.

  8) Log
    There are some interfaces about log files, but not all of them are useful for developers. So we just discuss a
    part of them.

    a) mln_log(err_lv,msg,...);
       This interface is widely used in Melon.
       We use it to record log message.
       The first argument is log level. There are five levels:
           none, report, debug, warn and error.
       The initial log level can be set in the configuration file. The second argument is a string.
       It likes the first argument 'fmt' in printf(). And it supports some format control characters, such as
           %s, %S, %l, %d, %c, %f, %x, %X (=%lx in printf()), %u, %U (=%lu in printf()), %i (=%lld in 32-bit or
           %ld in 64-bit) and %I (=%llu in 32-bit or =%lu in 64-bit).
       Depending on the format control characters in msg, the rest arguments can be none or even more than one.

    b) char *mln_log_getDirPath(void);
       It returns the path of log files' directory.

    c) char *mln_log_getLogPath(void);
       It returns the path of a log file.

    d) char *mln_log_getPidPath(void);
       It returns the path of a pid file.
       The pid of the parent process is recorded in this file.

  9) Lexer
     In Melon, Lexer is very easy to use and customize.
     Even though, there are some open source lexer generators, such as flex, but they are not so much simple as
     Melon's.
     If you would like to create a lexer, you can follow these steps below:
     (1) #include "mln_lex.h"
     (2) Define structures, enumerations, declarations and some arrays.
         We just need to write a macro MLN_DEFINE_TOKEN_TYPE_AND_STRUCT() at the beginning of the file below
         #include "mln_lex.h".
         For example, if we are going to define a lexer, its functions' scope is 'extern'. The prefix of every
         function, structure and enumeration name is 'mln_test_lex'. Its token prefix is 'TEST' and it has three
         keywords 'for', 'while' and 'switch', as shown below.

         MLN_DEFINE_TOKEN_TYPE_AND_STRUCT(extern, mln_test_lex, TEST, TEST_TK_FOR, TEST_TK_WHILE, TEST_TK_SWITCH);

         The TEST_TK_FOR, TEST_TK_WHILE and TEST_TK_SWITCH are the token types of keywords 'for', 'while' and 'switch'.
         We should pay attention to the enumeration sequence that the custom special character declarations should be
         written before keywords'.
         And the sequence of keywords' enumerations should be identical with the sequence written in a keywords array. 
     (3) Then we need to define functions and related arrays,
         e.g.,
         MLN_DEFINE_TOKEN(mln_test_lex,
                          TEST,
                          {TEST_TK_FOR, "TEST_TK_FOR"},
                          {TEST_TK_WHILE, "TEST_TK_WHILE"},
                          {TEST_TK_SWITCH, "TEST_TK_SWITCH"});
         Now we have already defined 39 functions and a structure array.
         There are 33 functions are associated with processing special characters.
         One function is for setting custom functions to process special characters.
         One function is for creating token object.
         One is for destroying token object.
         One is for processing keywords.
         One is for processing all special characters' hooks.
         The last one function is for getting a token from a file or string buffer.
         The array maintains all special characters' handlers.
         You can refer to the include/mln_lex.h and src/mln_conf.c.
     (4) Set lexer's attributions and call MLN_LEX_INIT_WITH_HOOKS() to initialize a lexer object.
         e.g.,
             struct mln_lex_attr attr;
             ... //Set some special characters' processing hooks.
             mln_lex_t *lex = NULL;
             mln_lex_initWithHooks(mln_test_lex, lex, &attr);

         Now a lexer has been created. The structure of attr is defined as
             struct mln_lex_attr {
                 mln_alloc_t        *pool;
                 char              **keywords;
                 mln_lex_hooks_t    *hooks;
                 mln_u32_t           preprocess:1;
                 mln_u32_t           padding:31;
                 mln_u32_t           type;
                 mln_string_t       *data;
              };
         pool -- is a memory pool used in lexer. It is initilizaed by 'mln_alloc_init()'.
         keywords -- is a vector which records all keywords that we need and the last element in vector is NULL. 
         hooks -- is a structure record all callback functions and their customized datas of speciall characters.
         preprocess -- is a flag to switching on preprocessing or not.
         type -- is a initial input stream type. Its value are:
             MLN_INPUT_T_FILE -- file stream.
             MLN_INPUT_T_BUF  -- buffer stream.
         data -- is the initial input filename or buffer. It can be set NULL if user don't wanna set input stream now.

     (5) Preprocessing.
         The preprocessing function include three aspects.
         <a> include
         <b> define
         <c> if

         'include' is a capability to include other local file into the current input stream.
         We can use it as,
             @include "a.conf"
         or
             @include "/xxx/xxx/a.conf"

         'define' is a capability to define a macro.
         Example:
             #define FOO 6  /*define a macro 'FOO' */
             #FOO           /*use macro 'FOO', it should be start with '@'.*/
             #undef FOO     /*undefine the macro 'FOO'*/
         There are two macro will be defined automatically while initialized a lexer, '1' and 'true', their
         content is nil.

         'if' is a capability to choose which party input stream can be parsed to tokens.
         It only support if, if-else.
         Example:
             #if true                  /*'true' is a pre-defined macro*/
                 #define hello "world" /*define a macro named 'hello', its value is '"world"'.*/
                 #define test          /*define a macro named 'test', its value is nil*/
             #else
                 #if !false            /*'false' is not defined, but have a prefix character '!' which means not,
                                         so this condition is true*/
                     #undef test       /*undefine macro 'test'.*/
                 #endif
             #endif
         
     Even though, there are a lot of functions has been built in step c), but only three of them should be concerned.

     a) mln_test_lex_struct_t *mln_test_lex_new(mln_lex_t *lex, enum mln_test_lex_enum type);
        It initializes a new token.
        If memory is not enough, NULL will be returned.

     b) void mln_test_lex_free(mln_test_lex_struct_t *ptr);
        It frees a token object which is given by the argument.

     c) mln_test_lex_struct_t *mln_test_lex_token(mln_lex_t *lex);
        It returns a token object.
        If it is called again, the next token will be returned.
        If the lexer encounters the EOF, a token object with the type TK_xxx_TK_EOF will be returned.
        If lexer encounters an error, NULL will be returned and the error number will be set in it.

     Besides these three interfaces, there are some others we also need to know.
     a) void mln_lex_destroy(mln_lex_t *lex);
        It destroys the lexer object.
        But this function does not destroy all token objects those are created by a lexer object.

     b) char *mln_lex_strerror(mln_lex_t *lex);
        As strerror(), this function will return an error message.

     c) char mln_lex_getAChar(mln_lex_t *lex);
        Get the next character from a file or a string buffer.
        If lexer encounters EOF, MLN_EOF will be returned.
        If it encounters an error, MLN_ERR will be returned and error number will be set.

     d) int mln_lex_putAChar(mln_lex_t *lex, char c);
        It puts a character into the result buffer which is a string that xxx_token() returned.
        If it encounters an error, MLN_ERR will be returned and the error number will be set.

     e) void mln_lex_stepBack(mln_lex_t *lex);
        It steps back a character.
        If this interface is called between calling mln_lex_getAChar() twice, the returned characters via calling
        mln_lex_getAChar() twice are the same.

     f) int mln_lex_isLetter(char c);
        This interface is equivalent to
        if (c == '_' || isalpha(c)).

     g) int mln_lex_isOct(char c);
        This interface is equivalent to
        if (c >= '0' && c < '8').

     h) int mln_lex_isHex(char c);
        This interface is equivalent to
        if (isdigit(c) || (c >= 'a' && c <= 'f') || (c >= 'A' && c <= 'F')).

     i) int mln_lex_push_InputFileStream(mln_lex_t *lex, mln_string_t *path);
        This interface is push a new file stream into 'lex'.
        Then if we call PREFIX_NAME##_token(), it will return the token that came from the new file stream.

     j) int mln_lex_push_InputBufStream(mln_lex_t *lex, mln_string_t *buf);
        This interface is push a new buffer stream into 'lex'.
        Then if we call PREFIX_NAME##_token(), it will return the token that came from the new buffer stream.

     k) mln_lex_getPool(lex);
        Get the memory pool from 'lex'.

     l) mln_lex_cleanResult(lex);
        Clean the result buf in 'lex'.

     m) mln_lex_getCurFilename(lex);
        Get the name of current file stream in 'lex'.

     n) mln_lex_getResult(lex,res_pstr);
        Get the result buf in 'lex' into 'res_pstr'.
        The type of 'res_pstr' is 'mln_string_t *'.

     o) mln_lex_setError(lex,err);
        Set the error in 'lex'. The value of 'err' are:
            MLN_LEX_SUCCEED
            MLN_LEX_ENMEM
            MLN_LEX_EINVCHAR
            MLN_LEX_EINVHEX
            MLN_LEX_EINVDEC
            MLN_LEX_EINVOCT
            MLN_LEX_EINVREAL
            MLN_LEX_EREAD
            MLN_LEX_EINVEOF
            MLN_LEX_EINVEOL
            MLN_LEX_EINPUTTYPE
            MLN_LEX_EFPATH
            MLN_LEX_EINCLUDELOOP
            MLN_LEX_EUNKNOWNMACRO
            MLN_LEX_EMANYMACRODEF
            MLN_LEX_EINVMACRO

  10) Configuration
     As shown below, this is the architecture of configuration.
     -------       -------        -------       -------
    |       |     |       |      |       |     |       |
    |  mln_ |---->| mln_  |----->|  mln_ |---->| mln_  |
    | conf_t|     | conf_ |      | conf_ |     | conf_ |
    |       |     |domain_|      | cmd_t |     | item_t|
    |       |     |t      |      |       |     |       |
    |       |     |       |      |       |      -------
    |       |     |       |      |       |\
    |       |     |       |       -------  \
    |       |     |       |\                ...
    |       |      -------  \
    |       |                ....
    |       |\
     -------  \
               ...
            Figure 3. Configuration architecture.

     Except mln_conf_item_t, other structures have a function pointer named search.
     In mln_conf_t, its prototype is
         typedef mln_conf_domain_t *(*search_domain)(mln_conf_t *, char *);
     This function is used to search a conf-domain.
     The first argument is a configuration object returned by mln_get_conf().
     The second argument is a string indicating the domain name.
     If domain is existent, the domain object (mln_conf_domain_t) will be returned. Otherwise, the return value is
     NULL.

     In mln_conf_domain_t, the prototype of function 'search' is
         typedef mln_conf_cmd_t *(*search_cmd) (mln_conf_domain_t *, char *);
     This function is used to search a conf-command.
     The first argument is a domain object. The second argument
     is the command name that we are looking for.
     If command is not existent, NULL will be returned.

     In mln_conf_cmd_t, the prototype of function 'search' is
         typedef mln_conf_item_t *(*search_item)  (mln_conf_cmd_t *, mln_u32_t);
     The first argument is a command object. The second one is an index indicating the position of the item in command.
     This index is start from 1.
     If index value is invalid, NULL will be returned.

     The mln_conf_item_t is the smallest unit in configuration.
     Its structure is
         struct mln_conf_item_s {
             enum {
                 CONF_NONE = 0,
                 CONF_STR,
                 CONF_CHAR,
                 CONF_BOOL,
                 CONF_INT,
                 CONF_FLOAT
            } type;
            union {
                 mln_string_t *s;
                 mln_s8_t c;
                 mln_u8_t b;
                 mln_sauto_t i;
                 float f;
            } val;
        };
     We can operate this structure directly to get the valuethat we need.

     About the usage of configuration file, there are something
     we need to know.
         1. Configuration file has a concept named domain.
            The number of domain is unlimited. But one domain cannot be nested in the other one, which means the
            level of domain is always 1.
         2. We can define any domains or commands in a configuration file (of course, their tokens should be valid to
            the lexer) and Melon won't report any warnings or errors while there is an unused command or domain
            written in file.
         3. The specification of configuration lexical analyzer follows these rules below:
            I.   The name in the configuration file should be start with a letter or '_'. And the rest characters can
                 be composed by digit, letter and '_'.
            II.  Domain can be defined by a closure which is composed by a domain name, a left brace and a right
                 brace at least.
            III. Except domain, the others are all called command.
                 The first token in a command is the command name.
                 And the rest tokens are called items. The number of item in a command can be 0.
            IV.  The type of an item can be the one of following types:
                     string, character, boolean, integer and float.
                 Their written form is compatible with C language.
            V.   Every command should be ended by a ';'.
            VI.  The way of writing comments is the same as C language.
         4. There are two keywords that we support, 'on' and 'off'.
            Their value is 1 and 0 (type CONF_BOOL) recorded in variable 'b' of union 'val' in an item object.

     There are some other interfaces we need to know.
     a) mln_conf_t *mln_get_conf(void);
        It gets a 'mln_conf_t' object.
        Then we can use its 'search' to find out the domain that we need.
        The return value won't be NULL until Melon crashed.

     b) mln_u32_t mln_conf_get_cmdNum(mln_conf_t *cf, char *domain);
        It returns the number of commands in the domain.
        If domain is not existent, NULL will be returned.

     c) void mln_conf_get_cmds(mln_conf_t *cf, char *domain, mln_conf_cmd_t **vector);
        It puts all commands in the domain into the third argument.
        Vector should be allocated before calling.

     d) mln_u32_t mln_conf_get_argNum(mln_conf_cmd_t *cc);
        It returns the number of items which belong to 'cc'.

     e) mln_conf_hook_t *mln_conf_set_hook(reload_handler reload, void *data);
        This interface is used to set a callback function which is used to reload one or more configuration items.
        The return value is a pointer indicating a chain node, which can be used to unset the hook.
        If memory is not enough, NULL will be returned.

     f) void mln_conf_unset_hook(mln_conf_hook_t *hook);
        This interface is used to unset a callback function which has been set in the global reload chain.

  11) Event
     Just like libevent, Melon's event module also integrates epoll, kqueue and select.
     It supports three kinds of event: timer event, signal event and file descriptor event.

     a) mln_event_t *mln_event_init(mln_u32_t is_main);
        It initializes an event object.
        is_main -- indicates whether the event object is initialized as a main event object.

     b) void mln_event_destroy(mln_event_t *ev);
        It destroys an event object.

     c) int mln_event_set_fd(mln_event_t *event,
                             int fd, 
                             mln_u32_t flag,
                             int timeout_ms,
                             void *data,
                             ev_fd_handler fd_handler);
        This function sets a file descriptor event.
        The first argument is an event object.
        The second one is the file descriptor that we are interested.
        The third one is a flag indicating the type of this event.
        Some flags are listed below:
            I.    M_EV_RECV
                  This flag indicates the event is a read event.
            II.   M_EV_SEND
                  Indicates the event is a write event.
            III.  M_EV_ERROR
                  Indicates the event is an error event.
            IV.   M_EV_ONESHOT
                  Indicates the event only triggered once.
            V.    M_EV_NONBLOCK
                  Set file descriptor to be non-blocking mode.
            VI.   M_EV_BLOCK
                  Set file descriptor to be blocking mode.
            VII.  M_EV_APPEND
                  Set this flag will retain the old event type and the new type.
            VIII. M_EV_CLR
                  Remove this file descriptor event.
        I, II, III, IV, V (or VI), VII can be used in the same one event combined with '|'.
        The fourth is a millisecond timer. If we don't want to set a timer, we can set this value to be M_EV_UNLIMITED.
        If we need to modify the event type of a file descriptor, and we don't want to modify its timer, we can set
        this value to be M_EV_UNMODIFIED.                
        The fifth is a user data that will be passed to a function which is given by the last argument.
        The last one is a function pointer, its prototype is
            typedef void (*ev_fd_handler) (mln_event_t *, int, void *);
        There are three arguments of function 'fh_handler': an event object, a file descriptor and a user data.
        If an event is failed to set, -1 will be returned. Otherwise, the returned value is 0.

     d) int mln_event_set_timer(mln_event_t *event, mln_u32_t msec, void *data, ev_tm_handler tm_handler);
        It sets a timer event.
        The first argument is an event object.
        The second one is a millisecond timer. Its unit is 10ms.
        Third argument is a user data.
        The last one is an event handler. Its prototype is
            typedef void (*ev_tm_handler) (mln_event_t *, void *);
        The arguments of 'tm_handler' are an event object and a user data.
        If an event is failed to set, -1 will be returned. Otherwise, the returned value is 0.

     e) int mln_event_set_signal(mln_event_t *event,
                                 mln_u32_t flag,
                                 int signo,
                                 void *data,
                                 ev_sig_handler sg_handler);
        It sets a signal event.
        The first argument is an event object.
        The second one is a flag indicating the type of event to install or uninstall the event handler. Its value
        can be M_EV_SET or M_EV_UNSET.
        The third one is the signal number that we catch.
        The fourth one is a user data.
        Last one is an event handler. Its prototype is
            typedef void (*ev_sig_handler) (mln_event_t *, int, void *);
        The arguments of 'sg_handler' are an event object, a signal number and a user data.
        If an event is failed to set, -1 will be returned. Otherwise, 0 will be returned.
        It is different between this interface and the one in libevent. We allow to set signal event handlers (no
        matter they are different or not) for the same one signal into one or many event objects.
        When a signal raised, the handlers that are whether in the same event object or not, will be called in their
        thread.

     f) void mln_event_dispatch(mln_event_t *event);
        It dispatches every event.
        If a routine jumps into this function, it won't be out until encountering two situations:
            calling mln_event_set_break() to break out
        or
            a child process is forked.

     g) void mln_event_set_break(mln_event_t *ev);
        It lets the routine break out from mln_event_dispatch().

     h) void mln_event_set_callback(mln_event_t *ev, dispatch_callback dc, void *dc_data);
        Besides fd, timer and signal callback handlers, there is another one (this) can be called to process some
        other things in dispatch routine.
        The second argument is a function pointer, its prototype is
            typedef void (*dispatch_callback) (mln_event_t *, void *);

     i) void mln_event_set_fd_timeout_handler(mln_event_t *event, int fd, void *data, ev_fd_handler timeout_handler);
        This interface will set a callback handler for processing the case that the fd's timer expired.

  12) Connection I/O
     Connection I/O, for now, only supports TCP (actually, it also supports file I/O).

     a) int mln_tcp_conn_init(mln_tcp_conn_t *tc, int sockfd);
        Initialize a 'mln_tcp_conn_t' structure and associate with the socket file descriptor 'sockfd'.

     b) void mln_tcp_conn_destroy(mln_tcp_conn_t *tc);
        Destroy a 'mln_tcp_conn_t' structure.

     c) void mln_tcp_conn_append(mln_tcp_conn_t *tc, mln_chain_t *c, int type);
        Add 'c' to the end of a chain in 'tc'.
        'type' has three value:
            I.   M_C_SEND
                 Indicating the send chain.
            II.  M_C_RECV
                 Indicating the receive chain.
            III. M_C_SENT
                 Indicating the sent chain.

     d) mln_chain_t *mln_tcp_conn_get_head(mln_tcp_conn_t *tc, int type);
        Get the first chain node pointer from a chain in 'tc'.
        'type' is the same as 'mln_tcp_conn_set'.

     e) mln_chain_t *mln_tcp_conn_remove(mln_tcp_conn_t *tc, int type);
        Remove and return the chain that 'type' indicates in 'tc'.

     f) mln_chain_t *mln_tcp_conn_get_tail(mln_tcp_conn_t *tc, int type);
        Get the last chain node from the chain that is indicated by 'type' from 'tc'.

     g) void mln_tcp_conn_append_chain(mln_tcp_conn_t *tc, mln_chain_t *c_head, mln_chain_t *c_tail, int type);
        Append whole chain 'c_head' to the specified chain in 'tc' which is indicated by 'type'.

     h) mln_chain_t *mln_tcp_conn_pop(mln_tcp_conn_t *tc, int type);
        Pop the first chain node from the specified chain from 'tc' which is specified by 'type'.

     i) mln_tcp_conn_send(mln_tcp_conn_t *tc);
        Send the data of 'send' chain in 'tc' to the peer of a connection.

     j) mln_tcp_conn_recv(mln_tcp_conn_t *tc, mln_u32_t flag);
        Receive the data from the peer of a connection and add the data to the end of 'receive' chain in 'tc'.
        'flag' indicates the storage method for the receive data.
            I.   M_C_TYPE_FOLLOW
                 Set the method to be as same as latest one.
            II.  M_C_TYPE_MEMORY
                 Store the receive data in memory.
            III. M_C_TYPE_FILE
                 Store the receive data in a temporary file.

     k) mln_tcp_conn_get_fd(pconn);
        Return the socket file descriptor of 'pconn' (its type is mln_tcp_conn_t).

     l) mln_tcp_conn_set_fd(pconn, fd);
        Set 'fd' to the socket file descriptor in 'pconn'.

     m) mln_tcp_conn_get_pool(pconn);
        Return the pool object pointer of 'pconn'.

     n) mln_tcp_conn_send_empty(pconn);
        Test whether the 'send' chain is empty or not.

     o) mln_tcp_conn_recv_empty(pconn);
        Test whether the 'receive' chain is empty or not.

     p) mln_tcp_conn_sent_empty(pconn);
        Test whether the 'sent' chain is empty or not.

  13) Global resources Initialization
     a) void mln_global_init(void);
        This interface is used to initialize global variables.
        It is called in the case that configuration file is not loaded.
        If developers need to initialize some global variables independent of the configuration, they can write the
        code directly in this function.

     b) int mln_init_all_resource(void);
        This interface is used to initialize global variables those are dependent on the configuration.
        People can write the code directly in this function.

  14) Queue

     struct mln_queue_attr {
         mln_uauto_t            qlen;
         queue_free             free_handler;
     };

     This structure is used to initialize a queue data structure.
     qlen -- is the length of the queue.
     free_handler -- is a function pointer to free the element's
     memory in queue. Its prototype is
         typedef void (*queue_free)(void *);
     The argument is the data pointer of an element.

     There are 12 interfaces for this data structure.
     a) mln_queue_empty(q)
         It is used to test whether the queue is empty.

     b) mln_queue_full(q)
        It is used to test whether the queue is full.

     c) mln_queue_length(q)
        It is used to get the queue length.

     d) mln_queue_element(q)
        It is used to get the number of elements currently in queue.

     e) mln_queue_t *mln_queue_init(struct mln_queue_attr *attr);
        It is used to initialize a queue object.

     f) void mln_queue_destroy(mln_queue_t *q);
        It is used to destroy a queue object.

     g) int mln_queue_append(mln_queue_t *q, void *data);
        It is used to append an element to the queue.

     h) void *mln_queue_get(mln_queue_t *q);
        It is used to get the first element in the queue.

     i) void mln_queue_remove(mln_queue_t *q);
        It is used to remove the first element from the queue.
        And this interface won't free the memory of the first element.

     j) void *mln_queue_search(mln_queue_t *q, mln_uauto_t index);
        It is used to search an element via 'index'.
        'index' starts from 0.

     k) void mln_queue_free_index(mln_queue_t *q, mln_uauto_t index);
        It is used to remove the element that located by 'index' in the queue and free its memory.

     l) int mln_queue_scan_all(mln_queue_t *q, queue_scan scan_handler, void *udata);
        It is used to scan all elements in the queue.
        scan_handler -- is a function pointer that is used to process every element. Its prototype is
            typedef int (*queue_scan)(void *, void *);
        The first argument is the pointer of an element. The second one is a user data.

  15) Stack

     struct mln_stack_attr {
         stack_free               free_handler;
         stack_copy               copy_handler;
     };
     This structure is used to initialize a stack object.
     free_handler -- is a function pointer to free stack data.
     Its prototype is
         typedef void (*stack_free)(void *);
     The argument is a stack data.
     copy_handler -- is a function pointer to duplicate a stack data.
     Its prototype is
         typedef void *(*stack_copy)(void *);
     The argument is the stack data.

     There are 7 interfaces for stack.
     a) mln_stack_empty(s)
        It is used to test whether the stack is empty.

     b) mln_stack_t *mln_stack_init(struct mln_stack_attr *attr);
        This interface is used to initialize a stack object.

     c) void mln_stack_destroy(mln_stack_t *st);
        This interface is used to destroy a stack object.

     d) int mln_stack_push(mln_stack_t *st, void *data);
        It is used to push a data into the stack.

     e) void *mln_stack_pop(mln_stack_t *st);
        It is used to pop a data out of the stack. 

     f) void *mln_stack_top(mln_stack_t *st);
        It is used to get the top data in the stack.

     g) mln_stack_t *mln_stack_dup(mln_stack_t *st, void *udata);
        It is used to duplicate a stack data.
        'udata' is a customized data, it will be passed to the 'copy_handler'.

     h) int mln_stack_scan_all(mln_stack_t *st, stack_scan scanner, void *data);
        Scan all node in stack 'st'.
        'scanner' is a handler function to process every stack node. Its prototype is,
            typedef int (*stack_scan)(void *, void *);
        the first argument is the data in stack node, the second argument is the same as
        the 'data' passed to 'mln_stack_scan_all', that is a customized data.

  16) Parser and Parser Generator
     Parser can be used to parse a text which is in a file or buffer automatically.
     And it also can do some semantic actions.
     How to use it? Just follow these steps below.

     1. We have to think how many keywords or special characters that lexer has. Because the parse depends on it.
        In our example, I only define one keyword -- 'for'.

     2. We have to think what kind of syntax that we need.
        That means we need to determine the productions.
        In our example,
            ss -> s eof
            s  -> v = e
            s  -> e
            e  -> v
            v  -> ID
            v  -> * e
            With these productions, we can write
            **a = ***c
        in a file and it will pass the parsing.

     3. How to get a parser? We can use parser generator to generate it.
        How to define a parser generator? In our example, we can write
            MLN_DECLARE_PASER_GENERATOR(static,
                                        test1,
                                        TEST1,
                                        TEST1_TK_FOR);
            MLN_DEFINE_PASER_GENERATOR(static,
                                       test1,
                                       TEST1,
                                      {TEST1_TK_FOR, "TEST_TK_FOR"});
            mln_production_t prod_tbl[] = {
                {"SS:S TEST1_TK_EOF", NULL},
                {"S:V TEST1_TK_EQUAL E", NULL},
                {"S:E", NULL},
                {"E:V", NULL},
                {"V:TEST1_TK_ID", NULL},
                {"V:TEST1_TK_AST E", NULL}
            };
        Now, we have defined a parser generator.
        'prod_tbl' is the production array. The 'mln_production_t' is defined as
            typedef struct {
                char                     *production;
                semantic_func             func;
            } mln_production_t;
        production -- is a string indicating a production.
        func -- is a function pointer that is used to execute some semantic actions. Its prototype is
            typedef int (*semantic_func)(mln_factor_t *left,
                                         mln_factor_t **right,
                                         void *data);
        The first argument is indicating the left terminal.
        The second argument is an array that includes all right non-terminals.
        The last one is a user data.
        'mln_factor_t' is defined as
            struct mln_factor_s {
                void                     *data;
                enum factor_data_type     data_type;
                nonterm_free              nonterm_free_handler;
                nonterm_copy              nonterm_copy_handler;
                mln_sauto_t               cur_state;
                int                       token_type;
                mln_u32_t                 line;
            };
            enum factor_data_type {
                M_P_TERM,
                M_P_NONTERM
            };
        data -- is a structure pointer. If 'data_type' is M_P_TERM, the type of 'data' will be 'test1_struct_t'.
        Otherwise, its type will be a custom type.
        nonterm_free_handler -- is a callback function to free the 'data' if 'data_type' is M_P_NONTERM.
        nonterm_copy_handler -- is a callback function to duplicate the 'data' if 'data_type' is M_P_NONTERM.
        cur_state -- is the state number in state transition table. Just ignore it.
        token_type -- is the type of token, such as TEST1_TK_FOR, TEST1_TK_AST, etc.
        line -- is the number of lines that token located in a text.

        MLN_DECLARE_PASER_GENERATOR and MLN_DEFINE_PASER_GENERATOR define a lot of functions, but only three
        functions we care.

        a) void *test1_parser_generate(mln_production_t *prod_tbl, mln_u32_t nr_prod);
           This function is used to generate a big table that will be used in the parser.          

        b) int test1_parse(struct mln_parse_attr *pattr);
           This function is used to parse a text.
           pattr -- is a data structure pointer, it's defined as
               struct mln_parse_attr {
                   mln_production_t         *prod_tbl;
                   mln_lex_t                *lex;
                   void                     *pg_data;
                   void                     *udata;
               };
           prod_tbl -- is the production array.
           lex -- is a initialized lexer.
           pg_data -- is the data that test1_parser_generate() returned.
           udata -- is the user data that the third argument of semantic function.

        c) void test1_pg_data_free(void *pg_data);
        It is used to free the data that test1_parser_generate() returned.

     4. Get the intermediate result.
        call function test1_parser_generate().
            void *data;
            data = test1_parser_generate(prod_tbl, sizeof(prod_tbl)/sizeof(mln_production_t));
            if (data == NULL) {
                mln_log(error, "parser generate failed.\n");
                ...
            }

     5. Initialize the lexer.
        We assume that the text which is going to be parsed is in a buffer not file.

            mln_string_t test = mln_string("**a = ***c");

            char *keywords[] = {"for", NULL};

            mln_alloc_t *pool = mln_alloc_init();

            mln_lex_t *lex = NULL;
            struct mln_lex_attr lattr;
            lattr.keywords = keywords;
            lattr.hooks = NULL;
            lattr.preprocess = 1;
            lattr.type = M_INPUT_T_BUF;
            lattr.data = &test;
            lex = mln_lex_init(&lattr);
            if (lex == NULL) {
                mln_log(error, "...\n");
                test1_pg_data_free(ret_data);
                ...
            }

     6. Parse
        Now, we can parse the text.
            struct mln_parse_attr pattr;
            pattr.pool = pool;
            pattr.prod_tbl = prod_tbl;
            pattr.lex = lex;
            pattr.pg_data = data;
            pattr.udata = NULL;
            if (test1_parse(&pattr) < 0) {
                mln_log(error, "Parse error.\n");
                ...
            }
        'data' can be reused in this phase.

     Now, the text has been parsed.
     We can build a A.S.T via semantic actions.

  17) Memory Pool
     The memory pool can help developer use memory more easily.
     a) mln_alloc_t *mln_alloc_init(void);
        Initialize a memory pool object.

     b) void mln_alloc_destroy(mln_alloc_t *pool);
        Destroy a memory pool object and free all memory blocks that it allocated.

     c) void mln_alloc_m(mln_alloc_t *pool, mln_size_t size);
        Allocate a memory block with size 'size'.

     d) void mln_alloc_c(mln_alloc_t *pool, mln_size_t size);
        Allocate a memory block with size 'size', and set its content to be 0.

     e) void mln_alloc_re(mln_alloc_t *pool,
                          void *ptr,
                          mln_size_t size);
        Re-allocate a memory block. That is the same as 'realloc' but allocating from a memory pool.

     f) void mln_alloc_free(void *ptr);
        Free a memory block to a memory pool.

  18) Chain & Buf
     These two structures do not have interfaces to operate.
     We should set them manually. Just like buf and chain in Nginx.

     typedef struct mln_buf_s {
         mln_u8ptr_t         send_pos;
         mln_u8ptr_t         pos;
         mln_u8ptr_t         last;
         mln_u8ptr_t         start;
         mln_u8ptr_t         end;
         struct mln_buf_s   *shadow;
         mln_off_t           file_send_pos;
         mln_off_t           file_pos;
         mln_off_t           file_last;
         mln_file_t         *file;
         mln_u32_t           temporary:1;
         mln_u32_t           mmap:1;
         mln_u32_t           in_memory:1;
         mln_u32_t           in_file:1;
         mln_u32_t           flush:1;
         mln_u32_t           sync:1;
         mln_u32_t           last_buf:1;
         mln_u32_t           last_in_chain:1;
     } mln_buf_t;

     typedef struct mln_chain_s {
         mln_buf_t          *buf;
         struct mln_chain_s *next;
     } mln_chain_t;

     a) mln_buf_size(pbuf);
        Calculate buf size.

     b) mln_buf_left_size(pbuf);
        Calculate the left size in a buf.

     c) mln_buf_t *mln_buf_new(mln_alloc_t *pool);
        Create a new buf structure and initialize it.

     d) mln_chain_t *mln_chain_new(mln_alloc_t *pool);
        Create and initialize a new chain node.

     e) void mln_buf_pool_release(mln_buf_t *b);
        Release a buf structure resource.

     f) void mln_chain_pool_release(mln_chain_t *c);
        Release a chain node structure resource.

     g) void mln_chain_pool_release_all(mln_chain_t *c);
        Release whole chain node.

  19) File
     a) mln_fileset_t *mln_fileset_init(mln_size_t max_file);
        Create and initilize a file set.

     b) void mln_fileset_destroy(mln_fileset_t *fset);
        Destroy a file set and release all file descriptors that it cached.

     c) mln_file_t *mln_file_open(mln_fileset_t *fset, const char *filepath);
        Open a file. And this file must be opened with read-only.
        This file object will be cached in 'fset'.

     d) void mln_file_close(void *pfile);
        Close a file. If 'pfile' is a regular file, it will be cached in its file set. Otherwise, it will be freed.

     e) mln_file_t *mln_file_open_tmp(mln_alloc_t *pool);
        Open a temporary file. This file will be created and opened with 'O_RDWR'.

     f) mln_file_fd(pfile);
        This interface is used to get a file descriptor from 'pfile'.
        'pfile' is a 'mln_file_t' pointer.

  20) HTTP
     HTTP is not quiet difficult to use. There are some functions. So we just,
     1) initialize a HTTP object.
     2) set its HTTP fields, status, version, method, type and handler,
     3) parse or generate a HTTP packet.
     4) finaly destroy the HTTP object.
     Here are the functions:
     a) mln_http_t *mln_http_init(mln_tcp_conn_t *connection, void *data, mln_http_handler body_handler);
        Initialize a HTTP object.
        'body_handler' is a callback handler. When we call mln_http_parse() or mln_http_generate(), this function
        will be called to process HTTP body.
        'data' is a user data. It will be passed to 'body_handler'.

     b) void mln_http_destroy(mln_http_t *http);
        Destroy a HTTP object.

     c) void mln_http_reset(mln_http_t *http);
        Reset HTTP object flags, such as version, method, etc.
        But the connection, memory pool, user data and body callback handler will not be reset.

     d) int mln_http_parse(mln_http_t *http, mln_chain_t **in);
        Parse HTTP packets.
        Return value:
           M_HTTP_RET_DONE:  parse complete and no error.
           M_HTTP_RET_OK:    parse incomplete and no error.
           M_HTTP_RET_ERROR: parse error.
        If an error ocurred, we can get the error code via mln_http_get_error().
        All parsed entries can be found in 'http'. we can use these functions below here to operate there entries.

     e) int mln_http_generate(mln_http_t *http, mln_chain_t **out_head, mln_chain_t **out_tail);
        Generate a HTTP packet.
        Return value: see mln_http_parse().

     f) int mln_http_set_field(mln_http_t *http, mln_string_t *key, mln_string_t *val);
        Set a field in a HTTP header.

     g) mln_string_t *mln_http_get_field(mln_http_t *http, mln_string_t *key);
        Get a field from a HTTP header.

     h) mln_string_t *mln_http_field_iterator(mln_http_t *http, mln_string_t *key);
        Get all values from some fields those keys are the same one.

     i) void mln_http_drop_field(mln_http_t *http, mln_string_t *key);
        Remove the field from the HTTP header field, which is indicated by 'key'.

     j) mln_http_get_connection(h);
        Get the tcp connection.

     k) mln_http_set_connection(h,c);
        Set the tcp connection.

     l) mln_http_get_pool(h);
        Get the memory pool.

     m) mln_http_set_pool(h,p);
        Set the memory pool.

     n) mln_http_get_data(h);
        Get the user data.

     o) mln_http_set_data(h,d);
        Set the user data.

     p) mln_http_get_uri(h);
        Get the URI.

     q) mln_http_set_uri(h,u);
        Set the URI.

     r) mln_http_get_args(h);
        Get the arguments.

     s) mln_http_set_args(h,a);
        Set the arguments.

     t) mln_http_get_status(h);
        Get the response status.

     u) mln_http_set_status(h,s);
        Set the response status.

     v) mln_http_get_method(h);
        Get the request method.

     w) mln_http_set_method(h,m);
        Set the request method.

     x) mln_http_get_version(h);
        Get the HTTP version.

     y) mln_http_set_version(h,v);
        Set the HTTP version.

     z) mln_http_get_type(h);
        Get the type of a HTTP packet.

     aa) mln_http_set_type(h,t);
         Set the type of a HTTP packet.

     ab) mln_http_get_handler(h);
         Get the callback handler.

     ac) mln_http_set_handler(h,hlr);
         Set the callback handler.

     ad) mln_http_get_response_msg(h);
         Get the response status string.

     ae) mln_http_set_response_msg(h,m);
         Set the response status string.
         Actually, this function is not very useful. Because mln_http_generate() will generate a HTTP response
         status string depending on the status code.

     af) mln_http_get_error(h);
         Get the error code.

     ag) mln_http_set_error(h,e);
         Set the error code.

     ah) mln_http_get_header(h);
         Get the header hash table object.

     ai) typedef int (*mln_http_handler)(mln_http_t *, mln_chain_t **, mln_chain_t **);
         This is the callback function's prototype.
         This function will be called in mln_http_parse() and mln_http_generate() to process the HTTP body.
         The second and third arguments are all second rank pointer variable.
         In mln_http_parse(), only the second argument will be set, and the third is NULL. The second one indicates
         a input chain. So that means we must freed the chain nodes which are processed in this function, and update
         this argument.
         In mln_http_generate, both of these arguments will be set. The first one points to the first output chain
         node, the other one points to the last output chain node. After we generate a HTTP body, we have to update
         these two arguments as the body.
         Finally, we discuss the return value.
         The return values are the same as mln_http_parse().
         But there is a thing we should know. If there is an error occured, we should set the error code via
         mln_http_set_error().

  21) Regular Expression
     Melon, now, has already support regular expression. And this capability is not relying on library pcre, but its
     own component.
     Providing this feature is trying to make the capability of parsing HTTP URI better.
     There are only two functions here.
     a) int mln_reg_match(mln_string_t *exp, mln_string_t *text);
        'exp' is the regular expression that user provided.
        'text' is the string that will be matched by 'exp'.
        This function will return a length that indicates how many bytes left in 'text' (which are not matched).
        If not matched, -1 will be returned.

     b) int mln_reg_equal(mln_string_t *exp, mln_string_t *text);
        This function will return a non-zero if 'text' is completely matched by 'exp'. Otherwise, zero will be
        returned.

     Melon support these symbols below,
     a) *
        Indicating none or more characters where are located before '*' can be matched.
     b) ?
        Indicating none or one character where is located before '+' can be matched.
     c) +
        Indicating at least one character where is located before '+' can be matched.
     d) .
        Anyone character can be matched.
     e) ^
        In common mode, this symbol means the first one character in text must be matched by the charactor or
        sub-expression followed '^'.
        In charcter mode, it means the current text character must not be matched by anyone in the square brackets.
     f) $
        This symbol must be matched the end of text.
     g) ()
        Sub-expression, which contain a small and complete regular expression.
     h) []
        Character mode.
        There is only one logical relation in this mode -- or.
        And only one text character can be matched by one of characters in the brackets.
     i) -
        This symbol only can be activated in character mode.
        It is used to indicate the scope that defined by the characters on either side of '-'.
     j) {}
        Indicating how many times that the character before '{' should be matched.
        {1} / {1,2} / {1,}
     k) \d
        Match a number.
     l) \D
        Match a nonnumeric character.
     m) \n
        Just like '\n' in C.
     n) \a
        Match a letter.
     o) \\
        Just like '\\' in C.

  22) JSON
     Melon, now, support JSON without relying on any json libraries.
     Here are the functions:
     a) mln_json_t *mln_json_new(void);
        Initialize a JSON object.

     b) void mln_json_free(void *json);
        Destroy a JSON object.

     c) mln_json_t *mln_json_parse(mln_string_t *jstr);
        Parse JSON string.

     d) mln_string_t *mln_json_generate(mln_json_t *j);
        Generate a JSON string.

     e) mln_json_t *mln_json_search_value(mln_json_t *j, mln_string_t *key);
        Search the JSON object value via 'key'.

     f) mln_json_t *mln_json_search_element(mln_json_t *j, mln_uauto_t index);
        Search the element from a JSON array.

     g) mln_uauto_t mln_json_get_array_length(mln_json_t *j);
        Get JSON array length.

     h) int mln_json_update_obj(mln_json_t *j, mln_json_t *key, mln_json_t *val);
        Update JSON object key-value.
        If 'key' is existent, the old value will be replaced by 'val' and freed.
        The type of 'j' should be M_JSON_OBJECT or M_JSON_NONE.

     i) int mln_json_add_element(mln_json_t *j, mln_json_t *value);
        Add an element into a JSON array.
        The type of 'j' should be M_JSON_ARRAY or M_JSON_NONE.

     j) int mln_json_update_element(mln_json_t *j, mln_json_t *value, mln_uauto_t index);
        Update JSON array element.
        The old value where is located by 'index' will be replaced by 'value' and free if it is existent.
        The type of 'j' must be M_JSON_ARRAY.

     k) void mln_json_reset(mln_json_t *j);
        Reset a JSON object.

     l) mln_json_t *mln_json_remove_object(mln_json_t *j, mln_string_t *key);
        Remove a key-value couple from a JSON object.
        The type of 'j' must be M_JSON_OBJECT.

     m) mln_json_t *mln_json_remove_element(mln_json_t *j, mln_uauto_t index);
        Remove an element from a JSON object.
        The type of 'j' must be M_JSON_ARRAY.

     n) M_JSON_IS_OBJECT(json);
        Test whether the type of 'json' is M_JSON_OBJECT.

     o) M_JSON_IS_ARRAY(json);
        Test whether the type of 'json' is M_JSON_ARRAY.

     p) M_JSON_IS_STRING(json);
        Test whether the type of 'json' is M_JSON_STRING.

     q) M_JSON_IS_NUMBER(json);
        Test whether the type of 'json' is M_JSON_NUM.

     r) M_JSON_IS_TRUE(json);
        Test whether the type of 'json' is M_JSON_TRUE.

     s) M_JSON_IS_FALSE(json);
        Test whether the type of 'json' is M_JSON_FALSE.

     t) M_JSON_IS_NULL(json);
        Test whether the type of 'json' is M_JSON_NULL.

     u) M_JSON_IS_NONE(json);
        Test whether the type of 'json' is M_JSON_NONE.

     v) M_JSON_GET_DATA_OBJECT(json);
        Get the object hash table if the type of 'json' is M_JSON_OBJECT.

     w) M_JSON_GET_DATA_ARRAY(json);
        Get the array red-black tree if the type of 'json' is M_JSON_ARRAY.

     x) M_JSON_GET_DATA_STRING(json);
        Get the string if the type of 'json' is M_JSON_STRING.

     y) M_JSON_GET_DATA_NUMBER(json);
        Get the number if the type of 'json' is M_JSON_NUM.

     z) M_JSON_GET_DATA_TRUE(json);
        Get the binary flag of TRUE if the type of 'json' is M_JSON_TRUE.

     aa) M_JSON_GET_DATA_FALSE(json);
         Get the binary flag of FALSE if the type of 'json' is M_JSON_FALSE.

     ab) M_JSON_GET_DATA_NULL(json);
         Get the variable of NULL if the type of 'json' is M_JSON_NULL.

     ac) M_JSON_SET_INDEX(json,i);
         Set the index of 'json' to be 'i'.

     ad) M_JSON_SET_TYPE_NONE(json);
         Set the type of 'json' to be M_JSON_NONE.

     ae) M_JSON_SET_TYPE_OBJECT(json);
         Set the type of 'json' to be M_JSON_OBJECT.

     af) M_JSON_SET_TYPE_ARRAY(json);
         Set the type of 'json' to be M_JSON_ARRAY.

     ag) M_JSON_SET_TYPE_STRING(json);
         Set the type of 'json' to be M_JSON_STRING.

     ah) M_JSON_SET_TYPE_NUMBER(json);
         Set the type of 'json' to be M_JSON_NUM.

     ai) M_JSON_SET_TYPE_TRUE(json);
         Set the type of 'json' to be M_JSON_TRUE.

     aj) M_JSON_SET_TYPE_FALSE(json);
         Set the type of 'json' to be M_JSON_FALSE.

     ak) M_JSON_SET_TYPE_NULL(json);
         Set the type of 'json' to be M_JSON_NULL.

     al) M_JSON_SET_DATA_STRING(json,str);
         Set the string value of 'json' to be 'str'.

     am) M_JSON_SET_DATA_NUMBER(json,num);
         Set the number of 'json' to be 'num'.

     an) M_JSON_SET_DATA_TRUE(json);
         Set the binary flag of TRUE in 'json'.

     ao) M_JSON_SET_DATA_FALSE(json);
         Set the binary flag of FALSE in 'json'.

     ap) M_JSON_SET_DATA_NULL(json);
         Set the variable of NULL in 'json'.

  23) Big Number
      For now, big number only can represent the number which is smaller than 2048-bit number.

      a) mln_bignum_positive(pbn);
         Switch big number's tag to be positive.

      b) mln_bignum_negative(pbn);
         Switch big number's tag to be negative.

      c) mln_bignum_t *mln_bignum_init(void);
         Create and initialize a big number.

      d) mln_bignum_t *mln_bignum_pool_init(mln_alloc_t *pool);
         Create and initialize a big number on 'pool'.

      e) void mln_bignum_free(mln_bignum_t *bn);
         Free a big number instance.

      f) void mln_bignum_pool_free(mln_bignum_t *bn);
         Free a big number instance to a memory pool.

      g) mln_bignum_t *mln_bignum_dup(mln_bignum_t *bn);
         Duplicate a big number instance.

      h) mln_bignum_t *mln_bignum_pool_dup(mln_alloc_t *pool, mln_bignum_t*bn);
         Duplicate a big number instance.
         The new instance is allocated on 'pool'.

      i) int mln_bignum_assign(mln_bignum_t *bn, mln_s8ptr_t sval, mln_u32_t len);
         Assign a value which is represented as string to a big number instance.
         'bn' is the big number instance.
         'sval' is the value which is represented as a string.
         'len' is the length of 'sval'.
         There are three representations of 'sval':
           I.  Decimal
               It should be started with '1'~'9'.
           II. Octal
               It must be started with '0' and the rest number must be '0'~'7'.
           III.Hexadecimal
               It must be started with '0x' and the rest number can be '0'~'9', 'a'~'f', 'A'~'F'.
           If we need a negative number, just add '-' to the head of 'sval'. Such as, -123, -0x89ab, -0337.

      j) void mln_bignum_add(mln_bignum_t *dest, mln_bignum_t *src);
         Big number addition.
         The result will be written in 'dest'.

      k) void mln_bignum_sub(mln_bignum_t *dest, mln_bignum_t *src);
         Big number substraction.
         The result will be written in 'dest'.

      l) void mln_bignum_mul(mln_bignum_t *dest, mln_bignum_t *src);
         Big number multiplication.
         The result will be written in 'dest'.

      m) int mln_bignum_div(mln_bignum_t *dest, mln_bignum_t *src, mln_bignum_t *quotient);
         Big number division.
         The quotient will be written in 'quotient' if 'quotient' is not NULL.
         The remainder will be written in 'dest'.

      n) int mln_bignum_pwr(mln_bignum_t *dest, mln_bignum_t *exponent, mln_bignum_t *mod);
         Big number involution.
         The result will be written in 'dest'.
         The result modulo 'mod' if 'mod' not NULL.

      o) int mln_bignum_compare(mln_bignum_t *bn1, mln_bignum_t *bn2);
         Compare two big numbers.
         Return value:
           -1 -- 'bn1' < 'bn2'
            0 -- 'bn1' == 'bn2'
            1 -- 'bn1' > 'bn2'.

      p) int mln_bignum_absCompare(mln_bignum_t *bn1, mln_bignum_t *bn2);
         Same as 'mln_bignum_compare', but ignore the negative sign.

      q) int mln_bignum_testBit(mln_bignum_t *bn, mln_u32_t index);
         Test the bit that is specified by 'index' is 0 or 1.
         'index' starts from 0.
         Return value: 0 -- bit is 0, 1 -- bit is 1.

      r) void mln_bignum_leftShift(mln_bignum_t *bn, mln_u32_t n);
         Left shift.
         'n' starts from 0.

      s) void mln_bignum_rightShift(mln_bignum_t *bn, mln_u32_t n);
         Right shift.
         'n' starts from 0.

      t) int mln_bignum_prime(mln_bignum_t *res, mln_u32_t bitwidth);
         Generate a big number.
         The result will be put into 'res'.
         'bitwidth' indicates the number of big number's bit.
         If 'bitwidth' is invalid, -1 will be returned.

      u) int mln_bignum_extendEulid(mln_bignum_t *a,
                                    mln_bignum_t *b,
                                    mln_bignum_t *x,
                                    mln_bignum_t *y,
                                    mln_bignum_t *gcd);
         Extend Eulid calculation.

      v) mln_bignum_isPositive(pbn);
         Test whether 'pbn' is positive or not.

      w) mln_bignum_isNegative(pbn);
         Test whether 'pbn' is negative or not.

      x) mln_bignum_getLength(pbn);
         Get the number of 4-octet data;
         So if we want to get the number of bytes, we can 'mln_bignum_getLength(pbn) * 4'.

      y) mln_bignum_zero();
         Initialize a big number to be zero.

      z) int mln_bignum_i2osp(mln_bignum_t *n, mln_u8ptr_t buf, mln_size_t len);
         Transform 'buf' into a mln_bignum_t 'n'.

      aa) int mln_bignum_os2ip(mln_bignum_t *n, mln_u8ptr_t buf, mln_size_t len);
         Transform 'n' into an octet string 'buf'.

  24) MD5
      a) void mln_md5_init(mln_md5_t *m);
         Initialize a MD5 instance.
         'm' can be allocated on stack or heap.

      b) mln_md5_t *mln_md5_new(void);
         Create a new MD5 instance.

      c) mln_md5_t *mln_md5_pool_new(mln_alloc_t *pool);
         Create a new MD5 instance on 'pool'.

      d) void mln_md5_free(mln_md5_t *m);
         Free a MD5 instance.

      e) void mln_md5_pool_free(mln_md5_t *m);
         Free a MD5 instance to a memory pool.

      f) void mln_md5_calc(mln_md5_t *m, mln_u8ptr_t input, mln_uauto_t len, mln_u32_t is_last);
         MD5 calculation.
         'm' is a MD5 instance.
         'input' is the content that need to be calculated.
         'len' is the length of 'input'.
         'is_last' is a flag to indicate whether 'input' is the last content or not.

      g) void mln_md5_toBytes(mln_md5_t *m, mln_u8ptr_t buf, mln_u32_t len);
         Put MD5 result into 'buf'.
         'len' is the length of 'buf'.
         The data filled in 'buf' is binary.

      h) void mln_md5_toString(mln_md5_t *m, mln_s8ptr_t buf, mln_u32_t len);
         Put MD5 result into 'buf'.
         'len' is the length of 'buf'.
         The data filled in 'buf' is a hex string.

  25) SHA1
      a) void mln_sha1_init(mln_sha1_t *s);
         Initialize a SHA1 instance.
         's' can be allocated on stack or heap.

      b) mln_sha1_t *mln_sha1_new(void);
         Create and initialize a new SHA1 instance on heap.

      c) mln_sha1_t *mln_sha1_pool_new(mln_alloc_t *pool);
         Create and initialize a new SHA1 instance on 'pool'.

      d) void mln_sha1_free(mln_sha1_t *s);
         Free SHA1 instance.

      e) void mln_sha1_pool_free(mln_sha1_t *s);
         Free SHA1 instance to a memory pool.

      f) void mln_sha1_calc(mln_sha1_t *s, mln_u8ptr_t input, mln_uauto_t len, mln_u32_t is_last);
         SHA1 calculation.
         's' is a SHA1 instance.
         'input' is the content that need to be calculated.
         'len' is the length of 'input'.
         'is_last' is a flag to indicate whether the 'input'
         is the last content or not.

      g) void mln_sha1_toBytes(mln_sha1_t *s, mln_u8ptr_t buf, mln_u32_t len);
         Put SHA1 result into 'buf'.
         'len' is the length of 'buf'.
         The data filled in 'buf' is binary.

      h) void mln_sha1_toString(mln_sha1_t *s, mln_s8ptr_t buf, mln_u32_t len);
         Put SHA1 result into 'buf'.
         'len' is the length of 'buf'.
         The data filled in 'buf' is a hex string.

      i) void mln_sha256_init(mln_sha256_t *s);
         Initialize a SHA256 instance.
         's' can be allocated on stack or heap.

      j) mln_sha256_t *mln_sha256_new(void);
         Create and initialize a new SHA256 instance on heap.

      k) mln_sha256_t *mln_sha256_pool_new(mln_alloc_t *pool);
         Create and initialize a new SHA256 instance on 'pool'.

      l) void mln_sha256_free(mln_sha256_t *s);
         Free SHA256 instance.

      m) void mln_sha256_pool_free(mln_sha256_t *s);
         Free SHA256 instance to a memory pool.

      n) void mln_sha256_calc(mln_sha256_t *s, mln_u8ptr_t input, mln_uauto_t len, mln_u32_t is_last);
         SHA256 calculation.
         All arguments are the same as 'mln_sha1_calc()'.

      o) void mln_sha256_toBytes(mln_sha256_t *s, mln_u8ptr_t buf, mln_u32_t len);
         The same as 'mln_sha1_toBytes()', but the first argument.

      p) void mln_sha256_toString(mln_sha256_t *s, mln_s8ptr_t buf, mln_u32_t len);
         The same as 'mln_sha1_toString()', but the first argument.

  26) DES
      a) void mln_des_init(mln_des_t *d, mln_u64_t key);
         Initialize a DES instance.
         'd' is the instance which can be allocated on stack or heap.
         'key' is a 4-byte A.K.A. 64-bit memory.

      b) mln_des_t *mln_des_new(mln_u64_t key);
         Create a new DES instance.

      c) mln_des_t *mln_des_pool_new(mln_alloc_t *pool, mln_u64_t key);
         Same as 'mln_des_new', but allocated on 'pool'.

      d) void mln_des_free(mln_des_t *d);
         Free a DES instance.

      e) void mln_des_pool_free(mln_des_t *d);
         Free a DES instance to a memory pool.

      f) mln_u64_t mln_des(mln_des_t *d, mln_u64_t msg, mln_u32_t is_encrypt);
         DES encrypt or decrypt.
         'd' is the DES instance.
         'msg' is a 64-bit text.
         'is_encrypt' is a flag to make 'msg' encrypt or decrypt.

      g) void mln_des_buf(mln_des_t *d,
                          mln_u8ptr_t in,
                          mln_uauto_t inlen,
                          mln_u8ptr_t out,
                          mln_uauto_t outlen,
                          mln_u8_t fill,
                          mln_u32_t is_encrypt);
         DES encrypt or decrypt.
         Break the 64-bit limitation.
         We provide an input buffer to encrypt or decrypt message and also provide an output buffer to get the
         cipher or text that function processed.

      h) void mln_3des_init(mln_3des_t *tdes, mln_u64_t key1, mln_u64_t key2);
         Initialize a 3DES instance.
         3DES need two 64-bit keys.

      i) mln_3des_t *mln_3des_new(mln_u64_t key1, mln_u64_t key2);
         Create a new 3DES instance.

      j) mln_3des_t *mln_3des_pool_new(mln_alloc_t *pool, mln_u64_t key1, mln_u64_t key2);
         Same as 'mln_3des_new', but allocated on 'pool'.

      k) void mln_3des_free(mln_3des_t *tdes);
         Free 3DES instance.

      l) void mln_3des_pool_free(mln_3des_t *tdes);
         Free 3Des instance to a memory pool.

      m) mln_u64_t mln_3des(mln_3des_t *tdes, mln_u64_t msg, mln_u32_t is_encrypt);
         3DES encrypt or decrypt.

      n) void mln_3des_buf(mln_3des_t *tdes,
                           mln_u8ptr_t in,
                           mln_uauto_t inlen,
                           mln_u8ptr_t out,
                           mln_uauto_t outlen,
                           mln_u8_t fill,
                           mln_u32_t is_encrypt);
         Same as 'mln_des_buf' but work on 3DES.

  27) RC4
      a) void mln_rc4_init(mln_u8ptr_t s, mln_u8ptr_t key, mln_uauto_t len);
         Initialize input data 's'.
         'key' can be any data.
         'len' is the length of 'key'.
         The length of 's' is 256 bytes.
         And 's' is a memory filled by 0.

      b) void mln_rc4_calc(mln_u8ptr_t s, mln_u8ptr_t data, mln_uauto_t len);
         Encrypt or decrypt 'data'.
         'len' is the length of 'data'.
         's' is a 256 bytes memory which is initialized by 'mln_rc4_init()'.

  28) AES
      a) int mln_aes_init(mln_aes_t *a, mln_u8ptr_t key, mln_u32_t bits);
         Initialize an AES instance.
         The 'key''s length is depending on 'bits'.
         There are three value of 'bits':
           I.   M_AES_128
           II.  M_AES_192
           III. M_AES_256
         The suffix number indicates how many bits the 'key' has.
         'a' is an AES instance which can be allocated on stack.

      b) mln_aes_t *mln_aes_new(mln_u8ptr_t key, mln_u32_t bits);
         Create a new AES instance from the heap.
         The values of 'bits' are the same as 'mln_aes_init()'.

      c) mln_aes_t *mln_aes_pool_new(mln_alloc_t *pool, mln_u8ptr_t key, mln_u32_t bits);
         The same as 'mln_aes_new()', but the instance is allocated from 'pool'.

      d) void mln_aes_free(mln_aes_t *a);
         Free an AES instance to the heap.

      e) void mln_aes_pool_free(mln_aes_t *a);
         Free an AES instance to a memory pool.

      f) int mln_aes_encrypt(mln_aes_t *a, mln_u8ptr_t text);
         AES encrypt.
         'text' must be a 128-bit data.

      g) int mln_aes_decrypt(mln_aes_t *a, mln_u8ptr_t cipher);
         AES decrypt.
         'cipher' must be a 128-bit data.

  29) Base64
      a) int mln_base64_encode(mln_u8ptr_t in,
                               mln_uauto_t inlen,
                               mln_u8ptr_t *out,
                               mln_uauto_t *outlen);
         Encode 'in' in Base64. 'out' and 'outlen' are output arguments.
         It will return -1 if memory not enough.

      b) int mln_base64_pool_encode(mln_alloc_t *pool,
                                    mln_u8ptr_t in,
                                    mln_uauto_t inlen,
                                    mln_u8ptr_t *out,
                                    mln_uauto_t *outlen);
         Same as 'mln_base64_encode' but the memory of 'out' is allocated by 'pool'.

      c) int mln_base64_decode(mln_u8ptr_t in,
                               mln_uauto_t inlen,
                               mln_u8ptr_t *out,
                               mln_uauto_t *outlen);
         Decode 'in'. 'out' and 'outlen' are output arguments.
         It will return -1 if memory not enough.

      d) int mln_base64_pool_decode(mln_alloc_t *pool,
                                    mln_u8ptr_t in,
                                    mln_uauto_t inlen,
                                    mln_u8ptr_t *out,
                                    mln_uauto_t *outlen);
         Same as 'mln_base64_decode' but the memory of 'out' is allocated by 'pool'.

      e) void mln_base64_free(mln_u8ptr_t data);
         Free 'data' which is returned by encode and decode functions via argument 'out'.

      f) void mln_base64_pool_free(mln_u8ptr_t data);
         Same as 'mln_base64_free' but free memory to a pool.

  30) RSA
      a) mln_rsa_key_t *mln_rsa_key_new(void);
         Create a new RSA key instance.

      b) mln_rsa_key_t *mln_rsa_key_pool_new(mln_alloc_t *pool);
         Create a new RSA key instance via a memory pool.

      c) void mln_rsa_key_free(mln_rsa_key_t *key);
         Free RSA key instance.

      d) void mln_rsa_key_pool_free(mln_rsa_key_t *key);
         Free RSA key instance to the memory pool.

      e) int mln_rsa_keyGenerate(mln_rsa_key_t *pub, mln_rsa_key_t *pri, mln_u32_t bits);
         Generate a couple of RSA keys.

      f) mln_string_t *mln_RSAESPKCS1V15PubEncrypt(mln_rsa_key_t *pub, mln_string_t *text);
         RSAAES-PKCS1-V1.5 public key encryption.

      g) mln_string_t *mln_RSAESPKCS1V15PubDecrypt(mln_rsa_key_t *pub, mln_string_t *cipher);
         RSAAES-PKCS1-V1.5 public key decryption.

      h) mln_string_t *mln_RSAESPKCS1V15PriEncrypt(mln_rsa_key_t *pri, mln_string_t *text);
         RSAAES-PKCS1-V1.5 private key encryption.

      i) mln_string_t *mln_RSAESPKCS1V15PriDecrypt(mln_rsa_key_t *pri, mln_string_t *cipher);
         RSAAES-PKCS1-V1.5 private key decryption.

      j) void mln_RSAESPKCS1V15Free(mln_string_t *s);
         Free the return value of 'mln_RSAESPKCS1V15PubEncrypt()', 'mln_RSAESPKCS1V15PubDecrypt()',
         'mln_RSAESPKCS1V15PriEncrypt()', 'mln_RSAESPKCS1V15PriDecrypt()', 'mln_RSASSAPKCS1V15SIGN()'.

      k) mln_string_t *mln_RSASSAPKCS1V15SIGN(mln_alloc_t *pool, mln_rsa_key_t *pri, mln_string_t *m, mln_u32_t hashType);
         RSASSA-PKCS1-V1.5 signature.

      l) int mln_RSASSAPKCS1V15VERIFY(mln_alloc_t *pool, mln_rsa_key_t *pub, mln_string_t *m, mln_string_t *s, mln_u32_t hashType);
         RSASSA-PKCS1-V1.5 verification.

      m) mln_RSAPublicKey_getValue(pkey,modulus,exponent);
         Get modulus and exponent from 'pkey'.

      n) mln_RSAPublicKey_getValueRef(pkey,pmodulus,pexponent);
         Get the pointers of modulus and exponent from 'pkey'.

      o) mln_RSAPublicKey_setValue(pkey,modulus,exponent);
         Set modulus and exponent into 'pkey'.

  31) Websocket
      Just like HTTP, the interfaces of websocket don't focus on the details of protocol transmition.
      The return values of all interfaces:
          I.   M_WS_RET_ERROR
               Indicates that protocol error.
          II.  M_WS_RET_OK
               Operation successful.
          III. M_WS_RET_FAILED
               Indicates that internal error, such as no memory.
          IV.  M_WS_RET_NOTWS
               Not a websocket protocol.
          V.   M_WS_RET_NOTYET
               Incomplete data.

      a) int mln_websocket_init(mln_websocket_t *ws, mln_http_t *http);
         Initialize a websocket instance, 'http' is an initialized HTTP instance.

      b) mln_websocket_t *mln_websocket_new(mln_http_t *http);
         Create and initialize a new websocket instance.

      c) void mln_websocket_destroy(mln_websocket_t *ws);
         Destroy the websocket instance indicated by 'ws'.

      d) void mln_websocket_free(mln_websocket_t *ws);
         Destroy and free the websocket instance indicated by 'ws'.

      e) void mln_websocket_reset(mln_websocket_t *ws);
         Reset a websocket instance.

      f) int mln_websocket_isWebsocket(mln_http_t *http);
         Test whether the 'http' is a websocket handshake request or not.

      g) int mln_websocket_validate(mln_websocket_t *ws);
         Test whether the 'ws' contain a correct websocket handshake response or not.

      h) int mln_websocket_set_field(mln_websocket_t *ws, mln_string_t *key, mln_string_t *val);
         Set a HTTP field to a websocket handshake package.

      i) mln_string_t *mln_websocket_get_field(mln_websocket_t *ws, mln_string_t *key);
         Get a HTTP field value from a websocket handshake package.

      j) int mln_websocket_match(mln_websocket_t *ws);
         Test every HTTP field via regular expression.

      k) int mln_websocket_handshake_response_generate(mln_websocket_t *ws, mln_chain_t **chead, mln_chain_t **ctail);
         Generate a websocket handshake response package.
         The output content can be got from 'chead' and 'ctail'.

      l) int mln_websocket_handshake_request_generate(mln_websocket_t *ws, mln_chain_t **chead, mln_chain_t **ctail);
         Generate a websocket handshake request package.
         The output content can be got from 'chead' and 'ctail'.

      m) int mln_websocket_text_generate(mln_websocket_t *ws,
                                         mln_chain_t **out_cnode,
                                         mln_u8ptr_t buf,
                                         mln_size_t len,
                                         mln_u32_t flags);
         Generate a text data frame.
         'out_cnode' is the output chain node.
         'buf' is the text content.
         'len' is the length of 'buf'.
         'flags' has some value those can be combined via '|'. Here are the flags,
             I.   M_WS_FLAG_NONE
                  Indicates nothing.
             II.  M_WS_FLAG_NEW
                  Indicates this data frame is the first fragment.
             III. M_WS_FLAG_END
                  Indicates this data frame is the last fragment.
             IV.  M_WS_FLAG_CLIENT
                  Indicates this data frame is built up by a websocket client.
             V.   M_WS_FLAG_SERVER
                  Indicates this data frame is built up by a websocket server.

      n) int mln_websocket_binary_generate(mln_websocket_t *ws,
                                           mln_chain_t **out_cnode,
                                           void *buf,
                                           mln_size_t len,
                                           mln_u32_t flags);
         Generate a binary data frame.
         All arguments' meaning are the same as 'mln_websocket_text_generate()'.

      o) int mln_websocket_close_generate(mln_websocket_t *ws,
                                          mln_chain_t **out_cnode,
                                          mln_u16_t status,
                                          mln_u32_t flags);
         Generate a control data frame for websocket closure.
         'reason' is the closure reason.
         'status' is the closure status code given below here,
              1) M_WS_STATUS_NORMAL_CLOSURE
              2) M_WS_STATUS_GOING_AWAY
              3) M_WS_STATUS_PROTOCOL_ERROR
              4) M_WS_STATUS_UNSOPPORTED_DATA
              5) M_WS_STATUS_RESERVED
              6) M_WS_STATUS_NO_STATUS_RCVD
              7) M_WS_STATUS_ABNOMAIL_CLOSURE
              8) M_WS_STATUS_INVALID_PAYLOAD_DATA
              9) M_WS_STATUS_POLICY_VIOLATION
             10) M_WS_STATUS_MESSAGE_TOO_BIG
             11) M_WS_STATUS_MANDATORY_EXT
             12) M_WS_STATUS_INTERNAL_SERVER_ERROR
             13) M_WS_STATUS_TLS_HANDSHAKE

      p) int mln_websocket_ping_generate(mln_websocket_t *ws, mln_chain_t **out_cnode, mln_u32_t flags);
         Generate a ping package.

      q) int mln_websocket_pong_generate(mln_websocket_t *ws, mln_chain_t **out_cnode, mln_u32_t flags);
         Generate a pong package.

      r) int mln_websocket_parse(mln_websocket_t *ws, mln_chain_t **in);
         Parse 'in' into a websocket data frame.

      s) int mln_websocket_generate(mln_websocket_t *ws, mln_chain_t **out_cnode);
         Generate a websocket data frame whose bit fields can be set by the macro-functions below here.

      t) mln_websocket_get_http(ws);
         Get the HTTP instance from the websocket instance 'ws'.

      u) mln_websocket_get_pool(ws);
         Get the memory pool instance from 'ws'.

      v) mln_websocket_get_connection(ws);
         Get the tcp connection instance from 'ws'.

      w) mln_websocket_get_uri(ws);
         Get the handshake request URI from 'ws'.

      x) mln_websocket_set_uri(ws,u);
         Set the handshake request URI 'u' into 'ws'.

      y) mln_websocket_get_args(ws);
         Get the handshake request argument from 'ws'.

      z) mln_websocket_set_args(ws,a);
         Set the handshake request argument into 'ws'.

      aa) mln_websocket_get_key(ws);
         Get the value of HTTP field 'Sec-Websocket-Key' from 'ws'.

      ab) mln_websocket_set_key(ws,k);
         Set the value of HTTP field 'Sec-Websocket-Key' into 'ws'.

      ac) mln_websocket_set_data(ws,d);
         Set user data 'd' into 'ws'.

      ad) mln_websocket_get_data(ws);
         Get the user data from 'ws'.

      ae) mln_websocket_set_content(ws,c);
         Set the content of data frame 'c' into 'ws'.

      af) mln_websocket_get_content(ws);
         Get the content of data frame from 'ws'.

      ag) mln_websocket_set_extHandler(ws,h);
         Set the extension handler 'h' into 'ws'.

      ah) mln_websocket_get_extHandler(ws);
         Get the extension handler from 'ws'.

      ai) mln_websocket_set_rsv1Bit(ws);
         Set rsv1 bit.

      aj) mln_websocket_reset_rsv1Bit(ws);
         Reset rsv1 bit.

      ak) mln_websocket_get_rsv1Bit(ws);
         Get rsv1 bit value.

      al) mln_websocket_set_rsv2Bit(ws);
         Set rsv2 bit.

      am) mln_websocket_reset_rsv2Bit(ws);
         Reset rsv2 bit.

      an) mln_websocket_get_rsv2Bit(ws);
         Get rsv2 bit value.

      ao) mln_websocket_set_rsv3Bit(ws);
         Set rsv3 bit.

      ap) mln_websocket_reset_rsv3Bit(ws);
         Reset rsv3 bit.

      aq) mln_websocket_get_rsv3Bit(ws);
         Get rsv3 bit value.

      ar) mln_websocket_set_opcode(ws,op);
         Set opcode 'op' into 'ws'. Here are the opcode values:
         1) M_WS_OPCODE_CONTINUE
            Indicates this data frame is the rest fragment but not last one.
         2) M_WS_OPCODE_TEXT
            Indicates this data frame is a text fragment, and this frame must be the first fragment.
            If bit 'fin' in data frame is set, this data frame also is the last fragment.
         3) M_WS_OPCODE_BINARY
            Indicates this data frame is a binary fragment, and this frame must be the first fragment.
            If bit 'fin' in data frame is set, this data frame also is the last fragment.
         4) M_WS_OPCODE_CLOSE
            Indicates this data frame is a control frame to notice peer the connection will be closed.
         5) M_WS_OPCODE_PING
            A kind of heartbeat data frame, the peer should send pong frame as answer.
         6) M_WS_OPCODE_PONG
            The answer of ping frame.

      as) mln_websocket_get_opcode(ws);
         Get opcode from 'ws'.

      at) mln_websocket_set_status(ws,s);
         Set status 's' into 'ws'.

      au) mln_websocket_get_status(ws);
         Get status from 'ws'.

      av) mln_websocket_set_contentLen(ws,l);
         Set content length 'l' into 'ws'.

      aw) mln_websocket_get_contentLen(ws);
         Get content length from 'ws'.

      ax) mln_websocket_set_contentFree(ws);
         Set contentFree bit. This bit indicates whether the content in 'ws' should be free when
         'mln_websocket_destroy()' or 'mln_websocket_free()' is called.

      ay) mln_websocket_reset_contentFree(ws);
         Reset contentFree bit.

      az) mln_websocket_get_contentFree(ws);
         Get contentFree bit value.

      ba) mln_websocket_set_fin(ws);
         Set 'fin'.

      bb) mln_websocket_reset_fin(ws);
         Reset 'fin'.

      bc) mln_websocket_get_fin(ws);
         Get value of 'fin'.

      bd) mln_websocket_set_maskBit(ws);
         Set bit 'mask'.

      be) mln_websocket_reset_maskBit(ws);
         Reset bit 'mask'.

      bf) mln_websocket_get_maskBit(ws);
         Get the value of bit 'mask'.

      bg) mln_websocket_set_maskingKey(ws,k);
         Set masking key 'k' into 'ws'.
         This value must be a 32-bit integer.

      bh) mln_websocket_get_maskingKey(ws);
         Get masking key from 'ws'.

  32) Tools
      a) void mln_UTCTime(time_t tm, struct UTCTime_s *uc);
         Parse 'tm' into structure UTCTime.
         The definition of structure UTCTime_s is
             struct UTCTime_s {
                 long        year;
                 long        month;
                 long        day;
                 long        hour;
                 long        minute;
                 long        second;
             };

      b) int mln_s2Time(time_t *tm, mln_string_t *s, int type)
         Parse 's' into 'tm'.
         The type of 's' is indicated by 'type', its value are:
             I.  M_TOOLS_TIME_UTC
             II. M_TOOLS_TIME_GENERALIZEDTIME

  33) ASN.1
      There are two parts, one is about decode, the other one is about encode.
      I. decode
      a) mln_asn1_deResult_getClass(pres);
         Get the class of decoded ASN.1 string.

      b) mln_asn1_deResult_getIdent(pres);
         Get the identifier of decoded ASN1.1 string.

      c) mln_asn1_deResult_setIdent(pres,id);
         Set the identifier.

      d) mln_asn1_deResult_isStructure(pres);
         Test whether the decoded result is a structure or not.

      e) mln_asn1_deResult_getCode(pres);
         Get the ASN.1 code which is relative to the decoded result.

      f) mln_asn1_deResult_getCodeLength(pres);
         Get the length of ASN.1 code which is relative to the decoded result.

      g) mln_asn1_deResult_getNContent(pres);
         Get the number of sub-result.

      h) mln_asn1_deResult_t *mln_asn1_decodeChain(mln_chain_t *in, int *err, mln_alloc_t *pool);
         Decode ASN.1 string from chain 'in'.

      i) mln_asn1_deResult_t *mln_asn1_decode(void *data, mln_u64_t len, int *err, mln_alloc_t *pool);
         Decode ASN.1 string from 'data'.
         'data' do not need to free. It will be freed while the function 'mln_asn1_deResult_free' called.

      j) mln_asn1_deResult_t *mln_asn1_decodeRef(void *data, mln_u64_t len, int *err, mln_alloc_t *pool);
         Decode ASN.1 string from 'data'.
         'data' should be free explicitly. It won't be freed while the function 'mln_asn1_deResult_free' called.

      k) void mln_asn1_deResult_free(mln_asn1_deResult_t *res);
         Free 'mln_asn1_deResult_t' data.

      l) mln_asn1_deResult_t *mln_asn1_deResult_getContent(mln_asn1_deResult_t *res, mln_u32_t index);
         Get the sub-result which is indicated by 'index' from 'res'.

      m) void mln_asn1_deResult_dump(mln_asn1_deResult_t *res);
         Dump decoded result and its sub-results.

      II. encode
      a) mln_asn1_enResult_setPool(pres,p);
         Set a memory pool into a encode-result object.

      b) mln_asn1_enResult_getPool(pres);
         Get the memory from 'pres'.

      c) mln_asn1_enResult_setClass(pres,c);
         Set a class into 'pres'.

      d) mln_asn1_enResult_getClass(pres);
         Get the class from 'pres'.

      e) mln_asn1_enResult_setIsStruct(pres);
         Set 'pres' to be a structure.

      f) mln_asn1_enResult_resetIsStruct(pres);
         Set 'pres' to be a non-structure.

      g) mln_asn1_enResult_getIsStruct(pres);
         Get the flag of 'isStruct' for testing whether 'pres' is structure or not.

      h) mln_asn1_enResult_setIdent(pres,id);
         Set an identifier into 'pres'.

      i) mln_asn1_enResult_getIdent(pres);
         Get the identifier of 'pres'.

      j) int mln_asn1_enResult_init(mln_asn1_enResult_t *res, mln_alloc_t *pool);
         Initialize an encode-result structure.

      k) void mln_asn1_enResult_destroy(mln_asn1_enResult_t *res);
         Destroy an encode-result structure.

      l) mln_asn1_enResult_t *mln_asn1_enResult_new(mln_alloc_t *pool);
         Create and initialize an encode-result structure.

      m) void mln_asn1_enResult_free(mln_asn1_enResult_t *res);
         Destroy and free an encode-result structure.

      n) int mln_asn1_encode_boolean(mln_asn1_enResult_t *res, mln_u8_t val);
         Encode 'res' into an ASN.1 string of boolean.

      o) int mln_asn1_encode_integer(mln_asn1_enResult_t *res, mln_u8ptr_t ints, mln_u64_t nints);
         Encode 'res' into an ASN.1 string of integer.

      p) int mln_asn1_encode_bitString(mln_asn1_enResult_t *res, mln_u8ptr_t bits, mln_u64_t nbits);
         Encode 'res' into an ASN.1 string of bit string.

      q) int mln_asn1_encode_octetString(mln_asn1_enResult_t *res, mln_u8ptr_t octets, mln_u64_t n);
         Encode 'res' into an ASN.1 string of octet string.

      r) int mln_asn1_encode_null(mln_asn1_enResult_t *res);
         Encode 'res' into an ASN.1 string of null.

      s) int mln_asn1_encode_objectIdentifier(mln_asn1_enResult_t *res, mln_u8ptr_t oid, mln_u64_t n);
         Encode 'res' into an ASN.1 string of object identifier.

      t) int mln_asn1_encode_utf8String(mln_asn1_enResult_t *res, mln_u8ptr_t s, mln_u64_t slen);
         Encode 'res' into an ASN.1 string of UTF8string.

      u) int mln_asn1_encode_printableString(mln_asn1_enResult_t *res, mln_s8ptr_t s, mln_u64_t slen);
         Encode 'res' into an ASN.1 string of printableString.

      v) int mln_asn1_encode_t61String(mln_asn1_enResult_t *res, mln_u8ptr_t s, mln_u64_t slen);
         Encode 'res' into an ASN.1 string of T61String.

      w) int mln_asn1_encode_ia5String(mln_asn1_enResult_t *res, mln_u8ptr_t s, mln_u64_t slen);
         Encode 'res' into an ASN.1 string of IA5String.

      x) int mln_asn1_encode_utctime(mln_asn1_enResult_t *res, time_t time);
         Encode 'res' into an ASN.1 string of UTC time.

      y) int mln_asn1_encode_generalizedTime(mln_asn1_enResult_t *res, time_t time);
         Encode 'res' into an ASN.1 string of Generalized time.

      z) int mln_asn1_encode_sequence(mln_asn1_enResult_t *res);
         Encode all sub-contents of 'res' into an ASN.1 string of Sequence.

      aa) mln_asn1_encode_sequenceOf(res);
         Encode all sub-contents of 'res' into an ASN.1 string of Sequence of.

      ab) int mln_asn1_encode_set(mln_asn1_enResult_t *res);
         Encode all sub-contents of 'res' into an ASN.1 string of Set.

      ac) int mln_asn1_encode_setOf(mln_asn1_enResult_t *res);
         Encode all sub-contents of 'res' into an ASN.1 string of Set of.

      ad) int mln_asn1_encode_merge(mln_asn1_enResult_t *dest, mln_asn1_enResult_t *src);
         Merge all sub-contents of 'dest' and 'src' into 'dest'.

      ae) int mln_asn1_encode_transChainOnce(mln_asn1_enResult_t *res, mln_chain_t **head, mln_chain_t **tail);
         Transform 'res' into an ASN.1 string stored in a chain.

      af) int mln_asn1_enResult_getContent(mln_asn1_enResult_t *res, mln_u32_t index, mln_u8ptr_t *buf, mln_u64_t *len);
         Get the sub-content which is indicated by 'index' from 'res'.

      ag) int mln_asn1_encode_implicit(mln_asn1_enResult_t *res, mln_u32_t ident, mln_u32_t index);
         Transform the content which is indicated by 'index' into Implicit type whose class will be set
         'M_ASN1_CLASS_CONTEXT_SPECIFIC' and identifier will be replaced by 'ident'.

  34) Thread Pool
      There is a problem in linux. I don't know whether it's a bug or not.
      If I fork a child process in the callback function 'process_handler' which is running on child thread,
      there is always 288-byte(64-bit)/144-byte(32-bit) block leak in child process.
      I checked I had already freed all blocks which were allocated by malloc(). But it still existed.
      I remember that there is a 288-byte(64-bit)/144-byte(32-bit) block allocated during calling pthread_create().
      But in child process, I can not access that 288-byte(64-bit)/144-byte(32-bit) memory in user mode,
      which means I can't free this memory block.
      And there is another thing which is that FreeBSD 10.0 i386 can not support fork() in thread perfectly.
      The child process will be blocked mostly. GDB can not attach that blocked process. Command 'truss' can not
      see which syscall it encountered. So if someone can explain it, I wiil be so grateful while you contact me
      immediately.
      Now, I just wanna say, fork() in thread is NOT recommended.

      There is a limitation to the thread pool. One process only can run it once. If you call this function in
      more than one thread, the unknown error may be occured.

      a) int mln_thread_pool_run(struct mln_thread_pool_attr *tpattr);
         This function is used to run (NOT only initialize) a thread pool.
         The definition of 'tpattr' is,
             struct mln_thread_pool_attr {
                 void                              *dataForMain;
                 mln_thread_process                 child_process_handler;
                 mln_thread_process                 main_process_handler;
                 mln_thread_dataFree                free_handler;
                 mln_u64_t                          condTimeout; /*ms*/
                 mln_u32_t                          max;
                 mln_u32_t                          concurrency;
             };
         'dataForMain' -- this variable is only provided for main thread. It will be passed into the main thread
                          callback function 'main_process_handler'.
         'child_process_handler' -- this callback function is provided for child thread(s). It will be called after
                                    the main thread dilivered a resource to child thread(s). Its prototype is,
                                        typedef int (*mln_thread_process)(void *);
                                    the argument is a resource structure pointer which is defined by user.
                                    And user must release it in this callback function.
         'main_process_handler' -- this callback function is provided for main thread. Its prototype is the same as
                                   'child_process_handler''s. The argument is 'dataForMain', not resource.
                                   When this thread pool running, the main thread is just simply to run this function.
                                   If your routine in this function returned, the thread pool would be cleaned and
                                   released.
         'free_handler' -- this callback function is provided for releaseing those unused resources when thread pool
                           quit. Its prototype is,
                               typedef void (*mln_thread_dataFree)(void *);
                           the argument is a resource structure pointer which thread pool wanna free.
         'condTimeout' -- this variable indicates a millisecond timeout timer for child thread(s). when someone child
                          thread's timer expired and there was no resource can be processed, this child thread would
                          quit.
         'max' -- the maximum number of child thread.
         'concurrency' -- this variable will be passed to 'pthread_setconcurrency()'.
                          This varibale may be ignored. Because, firstly not all OS platform support unix98,
                          secondly some OS platform just do nothing in 'pthread_setconcurrency()'.

      b) int mln_thread_pool_addResource(void *data);
         This function is used to deliver a resource to someone child thread.
         It only can be called in main thread, which means, the callback function 'main_process_handler'.

      c) void mln_thread_quit(void);
         This function can make thread pool quit.

      d) void mln_thread_ResourceInfo(struct mln_thread_pool_info *info);
         Get the information of thread pool.
         The prototype of 'struct mln_thread_pool_info' is
             struct mln_thread_pool_info {
                 mln_u32_t         maxNum;
                 mln_u32_t         idleNum;
                 mln_u32_t         curNum;
                 mln_size_t        resNum;
             };
         'maxNum' -- The allowed maximum number of child thread.
         'idleNum' -- The number of idle child thread.
         'curNum' -- The number of existed child thread.
         'resNum' -- The number of unhandled resource.

  34) AST
      This component aims to operate an AST, and it also includes the operations of state-shift table.

      a) void *mln_lang_parserGenerate(void);
         Generate a state-shift table for generating AST.

      b) void mln_lang_parserDestroy(void *data);
         Destroy the state-shift table.

      c) void *mln_lang_ast_generate(mln_alloc_t *pool, void *state_tbl, mln_string_t *data, mln_u32_t data_type);
         Generate an AST.
         'pool' -- Every node in AST is allocated from 'pool'.
         'state_tbl' -- state-shift table which is generated by 'mln_lang_parserGenerate'.
         'data_type' -- indicate the type of 'data'. It has two value, they are the same as 'type' in
                        'mln_lex_input_new()' -- M_INPUT_T_BUF and M_INPUT_T_FILE.
         'data' -- a string type data, its meaning is up to 'data_type'. If 'data_type' is M_INPUT_T_BUF,
                   'data' will contain a buffer which will be passed into a lexer. It 'data_type' is
                   M_INPUT_T_FILE, 'data' will contain a file path which will be passed into a lexer either.

      d) void mln_lang_ast_free(void *ast);
         Free an AST.

  35) Lang
      This component aims to execute a script task.

      a) mln_lang_t *mln_lang_new(mln_alloc_t *pool, mln_event_t *ev);
         Create a lang object. It supports multi-task.

      b) void mln_lang_free(mln_lang_t *lang);
         Destroy the 'lang' object.

      c) mln_lang_ctx_t *mln_lang_job_new(mln_lang_t *lang,
                                          mln_u32_t type,
                                          mln_string_t *data,
                                          void *udata,
                                          mln_lang_return_handler handler);
         Add a new task.
         'lang' -- lang object which is created by 'mln_lang_new'.
         'type' -- indicates the type of 'data', its values:
             I.  M_INPUT_T_BUF   -- 'data' is a string data including the script code.
             II. M_INPUT_T_FILE  -- 'data' is a string data including the path of script file.
         'udata' -- user data.
         'handler' -- a hook for fetching return value of the script file. Its prototype is,
             void (*mln_lang_return_handler)(mln_lang_ctx_t *);
             'mln_lang_ctx_t' is the context of script language.
         After calling this function, you can call 'mln_event_dispatch' immediatly, then the task will run
         automatically.

      d) int mln_lang_run(mln_lang_t *lang);
         This is a trigger function.
         After calling this function, you can call 'mln_event_dispatch' immediatly, then the task will run
         automatically.

      e) int mln_lang_msg_new(mln_lang_ctx_t *ctx, mln_string_t *name);
         Register a message communication item via argument 'name'.

      f) void mln_lang_msg_free(mln_lang_ctx_t *ctx, mln_string_t *name);
         Unregister a message communication item via the argument.

      g) void mln_lang_msg_setHandler(mln_lang_ctx_t *ctx, mln_string_t *name, mln_msg_c_handler handler);
         Set receiving handler for C-side code.

      h) int mln_lang_msg_sendMsg(mln_lang_ctx_t *ctx, mln_string_t *name, mln_lang_val_t *val, int isC);
         Send the data to the script-side(isC must be 1) via the message communication item which is
         located by 'name'.

      i) int mln_lang_ctx_resource_register(mln_lang_ctx_t *ctx, char *name, void *data, mln_lang_resource_free free_handler);
         Register a kind of resource which should be freed once ctx freed.
         'name' is the resource name.
         'data' resource manager structure.
         'free_handler' is the resource's free handler.

      j) void *mln_lang_ctx_resource_fetch(mln_lang_ctx_t *ctx, const char *name);
         Fetch script task's resource data.

      k) void mln_lang_ctx_suspend(mln_lang_ctx_t *ctx);
         Suspend the script task indicated by 'ctx'.

      l) void mln_lang_ctx_continue(mln_lang_ctx_t *ctx);
         Continue to run the script task indicated by 'ctx';

      m) int mln_lang_resource_register(mln_lang_t *lang, char *name, void *data, mln_lang_resource_free free_handler);
         Register a global resource that can be accessed by all script tasks those are in the same thread.

      n) void mln_lang_resource_cancel(mln_lang_t *lang, const char *name);
         Cancel a global resource.

      o) void *mln_lang_resource_fetch(mln_lang_t *lang, const char *name);
         Fetch global resource data;

  36) FEC
      This component is used to recover RTP packet. Generation and recovery operations are described in
      RFC 5109.
      a) mln_fec_t *mln_fec_new(void);
         Create fec instance.

      b) void mln_fec_free(mln_fec_t *fec);
         Destroy fec instance.

      c) mln_fec_result_t *mln_fec_encode(mln_fec_t *fec,
                                          uint8_t *packets[],
                                          uint16_t packLen[],
                                          size_t n,
                                          uint16_t groupSize);
         Encode RTP packets and generate some fec packets.
         'packets' is a vector of RTP packet.
         'packLen' is a vector of RTP packet length.
         'n' is the number of RTP packets.
         'groupSize' indicates how many RTP packets can be a group to generate an FEC packet.

      d) void mln_fec_result_free(mln_fec_result_t *fr);
         Destroy fec result instance that 'mln_fec_encode()' or 'mln_fec_decode()' returned.

      e) mln_fec_result_t *mln_fec_decode(mln_fec_t *fec,
                                          uint8_t *packets[],
                                          uint16_t *packLen,
                                          size_t n);
         Recovery RTP packet.
         If there is only one RTP packet lost, it can be recovered through this function.

      f) mln_fec_setPT(fec,_pt);
         Set PT field in RTP header.

      g) mln_fec_getResult(_result,index,_len);
         Get fec result data.

      h) mln_fec_getResultNum(_result);
         Get number of data that stored in fec result. 

  37) Matrix
      a) mln_matrix_t *mln_matrix_new(mln_size_t row, mln_size_t col, double *data, mln_u32_t isRef);
         Create matrix instance.
         'data' is an array.
         'isRef' indicates whether the 'data' should be freed or not while trying to free it.

      b) void mln_matrix_free(mln_matrix_t *matrix);
         Free matrix instance.

      c) mln_matrix_t *mln_matrix_mul(mln_matrix_t *m1, mln_matrix_t *m2);
         Matrix multiplication.

      d) mln_matrix_t *mln_matrix_inverse(mln_matrix_t *matrix);
         Matrix inversion.

  38) Reed-Solomon Code
      a) mln_rs_result_t *mln_rs_encode(uint8_t *dataVector, size_t len, size_t n, size_t k);
         Encode pieces of data in vector 'dataVector' and return 'n+k' pieces of data.
         And the type of 'dataVector' is 'uint8_t *' not 'uint8_t **'.
         'len' indicates the length of every element in 'dataVector'.
         'n' indicates how many elements placed in 'dataVector'.
         'k' indicates how many pieces of recovery data would be generated.

      b) void mln_rs_result_free(mln_rs_result_t *result);
         Free rs result that returned by 'mln_rs_encode()' or 'mln_rs_decode()'.

      c) mln_rs_result_t *mln_rs_decode(uint8_t **dataVector, size_t len, size_t n, size_t k);
         Recover lost data.
         'dataVector' is a vector stored some or all original data.
         'len' indicates the length of every element in 'dataVector'.
         'n' indicates the number of original data elements.
         'k' indicates the number of check elements generated from 'mln_rs_encode()'.
         If someone lost, the corresponing element in 'dataVector' should be NULL, but
         the number of 'dataVector''s element must be 'n+k'.

      d) mln_rs_result_getNum(_presult);
         Return how many pieces of data stored in '_presult' (mln_rs_result_t).

      e) mln_rs_result_getIndexData(_presult,index);
         Returned one piece of data that is indicated by 'index' stored in '_presult'.

  39) Garbage Collector
      This gc is made for melang script. It is a mark-sweep collector for solving Circular Reference
      problem.
      a) mln_gc_t *mln_gc_new(struct mln_gc_attr *attr);
         Create a new gc object. Definition of argument 'attr' is given below:
         struct mln_gc_attr {
             mln_alloc_t          *pool;
             gcItemGetter          itemGetter;
             gcItemSetter          itemSetter;
             gcItemFreer           itemFreer;
             gcMemberSetter        memberSetter;
             gcMoveHandler         moveHandler;
             gcRootSetter          rootSetter;
             gcCleanSearcher       cleanSearcher;
             gcFreeHandler         freeHandler;
         };
         pool is a memory pool. The prototypes of rest function pointers are shown below:

         <I>    typedef void *(*gcItemGetter)   (void *data);
                This function will be called in many interfaces for getting the a gc-data that
                is created by 'mln_gc_add()'. Argument is a user data that should be managed by
                garbage collector.

         <II>   typedef void  (*gcItemSetter)   (void *data, void *item);
                This function is used to set 'item' into 'data'.
                'item' is a gc-data. 'data' is an user data.

         <III>  typedef void  (*gcItemFreer)    (void *data);
                Free user data 'data'.

         <IV>   typedef void  (*gcMemberSetter) (mln_gc_t *gc, void *data);
                Gather every related data from 'data' and add in 'gc' to participate the calculation
                of garbage collection.

         <V>    typedef void  (*gcMoveHandler)  (mln_gc_t *destGC, void *data);
                Change something about garbage collector in user data 'data' to be related with
                'destGC'.

         <VI>   typedef void  (*gcRootSetter)   (mln_gc_t *gc, void *data);
                Gather every related data from 'data' and add in 'gc' to participate the calculation
                of root collection in garbage collection.
                'data' may not be the same as 'data' in other callback functions. It is identical to
                the second argument of 'mln_gc_collect()'.

         <VII>  typedef void  (*gcCleanSearcher)(mln_gc_t *gc, void *data);
                Gather every related data from 'data' and add in 'gc' to participate 'sweep'.
                'data' is an user data that is the same type as in 'gcMemberSetter'.

         <VIII> typedef void  (*gcFreeHandler)  (void *data);
                Clean all about garbage collector (gc-data) from user data 'data'.

      b) void mln_gc_free(mln_gc_t *gc);
         Free a 'gc'.
         In this function, callback function 'freeHandler' will be called to clean gc-data from
         every user data left in 'gc'.

      c) int mln_gc_add(mln_gc_t *gc, void *data);
         Add user data 'data' in 'gc'. This function is only add the user data that should be
         managed in 'gc'.
         In this function, callback function 'itemSetter' will be called to set a new gc-data
         into user data 'data.

      d) void mln_gc_suspect(mln_gc_t *gc, void *data);
         Mark user data 'data' as a suspected memory block.
         In this function, callback function 'itemGetter' will be called to get gc-data from
         'data'.

      e) void mln_gc_merge(mln_gc_t *dest, mln_gc_t *src);
         Merge 'src' into 'dest'. In this function, callback function 'moveHandler' will be
         called to modifiy something about new collector in user data.

      f) void mln_gc_addForCollect(mln_gc_t *gc, void *data);
         This function is used to add 'data' into 'gc' while collecting garbages (in
         'mln_gc_collect()'). You should call this function in callback function
         'memberSetter'.
         'data' is an user data that you want to add in 'gc'.

      g) int mln_gc_addForClean(mln_gc_t *gc, void *data);
         This function is used to add 'data' into 'gc' while collecting garbages (in
         'mln_gc_collect()'). You should call this function in callback function
         'cleanSearcher'.
         'data' is an user data that you want to add in 'gc'.

      h) void mln_gc_collect(mln_gc_t *gc, void *rootData);
         This function is used to collect garbage.
         'rootData' indicates a data that will be used in callback function 'rootSetter' to gather
         root memory blocks those are reachable and can be tracked.
         In this function, callback functions -- 'gcItemFreer', 'gcMemberSetter', 'gcRootSetter',
         'gcCleanSearcher' will be called.

      i) void mln_gc_remove(mln_gc_t *gc, void *data, mln_gc_t *procGC);
         Remove 'data' from 'gc'.
         'data' is an user data.
         If your scenario is multi-level collection, you may need to create more than one collector.
         So 'procGC' stand for the current collector.

5. Framework Usage
   It is very easy to use this framework. Before we use it, we have to initialize it.
   1) include header file.
       #include "mln_core.h"
   2) initilize argument of init-function.
       struct mln_core_attr attr;
       attr.argc = ...;
       ...
      The prototype of 'struct mln_core_attr' is,
       struct mln_core_attr {
           int                       argc;
           char                    **argv;
           mln_core_init_t           global_init;
           mln_core_worker_process_t worker_process;
       };
      'argc' normally equals to the first argument of 'main'.
      'argv' normally equals to the second argument of 'main'.
      'global_init' is a function to initialize some global variables. Its prototype is,
          typedef int (*mln_core_init_t)(void);
      'worker_process' is a function to process something in worker process. Its prototype is,
          typedef void (*mln_core_worker_process_t)(mln_event_t *);
        ‘mln_event_t' is the type of event object which is initialized by 'mln_event_init()'.
   3) call init-function.
      if (mln_core_init(&attr) < 0) {
          ...
      }
   That's all what we need to do.
   If you only want to use APIs, you can switch the status of configuration item 'framework' in configuration file
   to be 'off'. Then the framework only initialize some basic components and return immediately.

6. Process Module Development
   In Melon, there are two methods to develop process module.
   Let us discuss the first method.
   I. Actually, it is not much different between application program development and this one. We can write a normal
      application program and configure its path and parameters in Melon's configuration file.
      Now, let us follow these steps to develop a process module. Of course, we assume Melon has already installed.
      1) write a program.
         Example:
         #include <stdio.h>
         int main(int argc, char *argv[])
         {
             printf("This is a test. %s\n", argv[1]);
             return 0;
         }
      2) compile this source file.
         cc -o a a.c
      3) modify Melon's configuration file.
             vim /.../melon-xxx/conf/melon.conf
         We assume the new program's path is '/home/John/a'.
         There is a domian named 'exec_proc' in configuration  file. We can add a command in it.
             keepalive/default "/home/John/a" "argument1";
         Command name indicates the process type, there are two types: keepalive and default.
         'keepalive' will restart process when the process is killed by an unexpected error or system command 'kill'.
         'default' will do nothing when the process is terminated.
      4) move source files to the directory 'modules/test', and write a file 'configure' to build this new program
         automatically.
      5) start up Melon.
     Now, this new program is running.
     In the above example, the last argument in program 'a' is not 'argument1' but a string of a file descriptor,
     even though it is not written in the command. This file descriptor is a connection between the master process
     and a worker process.
     If command name is 'keepalive' and program 'a' is terminated, this connection will be closed, and the master
     process of Melon will receive this event and restart program 'a'. If command name is 'default' and the file
     descriptor is closed, Melon will never restart 'a' and ignore this event.

   Then, let us see the second method.
   II.This method will make Melon to be the real multiprocess model.
      In file '/.../melon-xxx/src/mln_process.c', there is a function named 'mln_worker_process', its prototype is
          void mln_worker_process(mln_event_t *ev);
      This function is the main routine of every worker process.
      The number of processes can be configured in 'melon.conf'.
      And these processes is a kind of private processes forked by the master process. And these processes will be
      supervised by the master. If any one of them is terminated, master will fork another one immediately.
      In this method, the module development is easier than the previous. We just need to write our code in function
      'mln_worker_process'. That's all.

   Now, the next essential is IPC. How to implement IPC?
   Melon provides an easy way. We don't need to modify the original source files. There is a directory for this,
   named 'ipc_handlers'.
   All files in this directory are used to define the IPC message types and their handlers.
   File name can be separated in two parts.
   The first one is the prefix of handlers' name. There are two handlers. One is for master process named
   'xxx_master' and the other is for worker process named 'xxx_worker'.
   The other part is the message type. This type will be defined in '/.../melon-xxx/include/mln_ipc.h', and we don't
   need to modify this file.
   Executing shell script 'configure', this file will be recreated automatically, then all message types are
   redefined.
   The prototypes of IPC handlers are:
       void prefix_master(mln_event_t *ev, void *f_ptr, void *buf, mln_u32_t len, void **udata_ptr);
       void prefix_worker(mln_event_t *ev, void *f_ptr, void *buf, mln_u32_t len, void **udata_ptr);
   The first argument is an event object that is related with this connection.
   The second one is a 'mln_fork_t' object. It can provide us some essentials about child process, such as TCP
   connection object.
   The third one is the data that master or worker received.
   The fourth one indicates the length of 'buf'.
   The last one is a custom data. The memory of it should be allocated and freed by the handler. Melon won't
   initialize or destroy it.
   About IPC, there is a case that the master may send a message to all child processes. Based on this case, Melon
   provides an interface to scan and process all child processes' objects.
   Its prototype is
       int mln_fork_scan_all(mln_event_t *ev, scan_handler handler, void *data);
       ev -- is the event object of the master process.
       handler -- is a callback function to process everyone child process object.
       data -- is a user data.
   Melon also provides other interfaces:
       1) mln_tcp_conn_t *mln_fork_get_master_connection(void);
          Get the connection that is used to communicate with master process.

       2) int mln_ipc_master_send_prepare(mln_event_t *ev,
                                          mln_u32_t type,
                                          void *buf,
                                          mln_size_t len,
                                          mln_fork_t *f_child);
          This function is used to notice system that there is a message need to be sent to the worker.
          So this function is provided for master process.
          'ev' is the event object containing the connection socket.
          'type' is the IPC type which is defined in directory
          'ipc_handlers/'.
          'buf' is the message content.
          'len' indicates the length of 'buf'.
          'f_child' is an object containing the information of worker process.

       3) int mln_ipc_worker_send_prepare(mln_event_t *ev, mln_u32_t type, void *msg, mln_size_t len);
          The functionality is the same as 'mln_ipc_master_send_prepare', but is provided for worker process.
          This function do not have argument 'f_child' cause worker process do not need it to locate master process.

7. Thread Module Development
   In Melon, there is only one model between multiprocess and multithread.
   We can trigger one of them via the configuration item 'thread_mode'. This command has only one parameter, it's
   a boolean value. If its value is 'on', multithread model will be triggered. Otherwise, multiprocess will be
   triggered.

   Thread module development is not only like process module development, but also like IPC development.
   There is a directory named 'threads' that is provided for maintaining thread module files. Every file is a thread
   module. The file name is the thread's alias.
   Every thread has an entrance named 'xxx_main' (xxx is the thread alias). Its prototype is
       int xxx_main(int argc, char **argv);
   Thread will start from this function. This function is the same as 'main()' in application program except its name.

   Not all of these thread modules in directory 'threads' can be started up. Only the thread modules that are written
   in the domain 'thread_exec' in 'melon.conf' can be started up.

   Now, let us see an example.
   1) create a thread module file.
          touch threads/hello
      Then the thread's alias is 'hello', and its entrance should be named 'hello_main'.

   2) edit the thread file.
          #include ...//include some essential header files.
          int hello_main(int argc, char *argv[])
          {
              //this is a thread module.
              mln_log(debug, "hello thread!\n");
              return 0;
          }
      This thread is going to do one thing that output 'hello thread!' to the log file.
      The last element in the second argument is a string indicating a file descriptor that is combined with a TCP
      connection for communicating with the main thread.
      And the first element in the second argument is the thread alias. The rest elements are all parameters.

   3) modify configuration file.
        thread_exec {
            //format: restart|default 'alias' ["parameter",...];
            //... Other threads
            restart "hello";
        }
      In this example, 'restart' is the command name that indicates Melon to restart this thread when it exited.
      There is another command name 'default', it indicates Melon to clean up the thread's resources when the thread
      is terminated.
      The type of alias and parameters must be the string.

   4) start up Melon.

   There is a command in the configuration file which is 'worker_process'.
   Its parameter notices Melon how many worker processes will be started up.
   If there is no thread in domain 'thread_exec', the worker process will still be started up and do nothing.

   Now, we discuss inter-thread communication.
   As shown in Figure 4, it is the inter-thread communication architecture.

     ------------------------------------------------
    |                 main thread                    |
     ------------------------------------------------
      |                 |         ......       |
     ---------------   ---------------    ---------------
    |child thread 1 | |child thread 2 |  |child thread N |
     ---------------   ---------------    ---------------
             Figure 4. Inter-thread communication.

   We can see the message is only transferred between the main thread and a child thread. If 'child_thread1' wants
   to send a message to 'child_thread2', the message should be delivered to the main thread at first, and then it
   would be transferred to the destination thread.
   This mechanism effectively reduces the coupling degree.
   It is very like the micro kernel model.

   Now, let us see the message format of inter-thread communication.
       typedef struct {
           mln_string_t              *dest;
           mln_string_t              *src;
           double                     f;
           void                      *pfunc;
           void                      *pdata;
           mln_sauto_t                sauto;
           mln_uauto_t                uauto;
           mln_s8_t                   c;
           mln_s8_t                   padding[7];
           enum {
               ITC_REQUEST,
               ITC_RESPONSE
           }                          type;
           int                        need_clear;
       } mln_thread_msg_t;
   dest --  is an alias indicating the destination thread.
   If this alias is not existent, message will be dropped by main thread, and the main thread won't send any error
   message to the source thread.
   src -- is an alias to indicatie the source thread. This variable is set by main thread.
   type -- indicating the type of message is a request or response.
   need_clear -- indicates whether the 'pdata' should be freed.
   The rest variables can be used to pass some arguments and (or) a function pointer.
   There are three interfaces we should know:
   a) void mln_thread_clearMsg(mln_thread_msg_t *msg);
      Free msg's memory.

   b) void mln_thread_exit(int exit_code);
      Exit the thread.

   c) void mln_thread_setCleanup(void (*tcleanup)(void *), void *data);
      Set a cleanup function that will be called after the thread exited.

8. Script language
   A. Data type
      This is a implicit-type script language.
      This are some data types:
          I.   Integer
          II.  Real
          III. Boolean
          IV.  Nil
          V.   Array
          VI.  Set
          VII. Object
      e.g.
      <I>   1   10  11  0x1
      <II>  1.2  0.38  3.14
      <III> true  false
      <IV>  nil
      <V>   [1, 2, 'aaa', 2.3, true, "score":60, 10:'hello']
      <VI>
            human {
                name;
                gender;
                age;
                @init(name, gender, age)
                {
                    this.name = name;
                    this.gender = gender;
                    this.age = age;
                }
            }
      <VII> John = $human;
            John.init('John', 'male', 21);

   B. Program flow control
      <I>    if
         e.g.
             a = 2;
             if (a < 3) a += 3;
             else if (a > 4) a -= 2;
             else ++a;
         e.g.
             a = 1;
             if (a < 2) a++;
             fi
         e.g.
             a = 1;
             if (a > 3) a--;
             else if (a < 2) a++;
             fi
         e.g.
             a = 1;
             if (a > 3) {
                a++;
                b = 10;
             }
             fi
         e.g.
             a = 1;
             if (a > 3) {
                 a--;
             } else if (a < 2) {
                 a++;
             } else {
                 a -= 2;
             }

      <II>   for
          e.g.
             array = [1, 2, 'a':3, 4];
             array2 = [];
             for (i = 0; i < 4; i++)
                 array2[] = array[i];
             array3 = [];
             for (i = 0; i < 4; i++) {
                 if (array[i] == array['a']) continue; fi
                 array3[] = array[i];
             }

      <III>  while
          e.g.
             i = 0;
             while (i < 10) {
                 i++;
             }

      <IV>   switch
          e.g.
             i = 'hello';
             switch (i) {
                 case 1:
                     i = 100;
                     break;
                 case 'hello':
                     i = 'world';
                 default:
                     i += ' hello';
                     break;
             }

      <V>    label
      <VI>   goto
          e.g.
             @foo ()
             {
                 a = 10;
             again:
                 a++;
                 if (a < 100) goto again; fi
                 return a;
             }

      <VII>  break
          e.g.
             for (i = 0; i < 1000; i++) {
                 if (i > 10) break; fi
             }
             i = 0;
             while (i < 1000) {
                 i++;
                 if (i > 10) break; fi
             }
             switch (i) {
                 case 'aaa':
                     i += 'bbb';
                     break;
                 default:
                     i = true;
                     break;
             }

      <VIII> continue
          e.g.
             j = 0;
             for (i = 0; i < 1000; i++) {
                 if (i % 2) continue; fi
                 ++j;
             }

      <IX>   return
          e.g.
             @foo1 ()
             {
                 return 1;
             }
             a = foo1();

          e.g.
             @foo2 ()
             {
                 a = 2;
                 return a + 1;
             }
             a = foo2();

          e.g.
             @foo3 ()
             {
                 @bar ()
                 {
                     return 100;
                 }
                 return bar;
             }
             a = foo3()();

          e.g.
             foo4 ()
             {
                 test {
                     a;
                     @b () {this.a = 10;}
                 }
                 return $test;
             }
             a = foo4();
             a.b();

          e.g.
             test {
                 a;
                 @b() {}
                 @c() {return this.b;}
             }
             a = $test;
             a.c()();

   C. Function
      We can call function in these two ways:
          foo();
      or
          @foo();
      difference between these two is:
          in the first case, 'foo' is only a local variable which type is function.
          in the second case, 'foo' can be a global function like 'mln_print'. If we
        want to use a global function in someone function's scope, we have to use
        this way.
      <I>   In global function
          e.g.
             @foo ()
             {
                 a = 1;
                 return a;
             }

      <II>  In other function
          e.g.
             @foo ()
             {
                 @b ()
                 {
                     return 'aaa';
                 }
                 return b;
             }

      <III> In set
          e.g.
             test
             {
                 var1;
                 var2;
                 @foo1() {return this.var1;}
                 @foo2() {return this.var2;}
             }
      <IV>  Refer argument
          e.g.
             @foo (&a)
             {
                 a = 'aaa';
             }
             a = 1;
             foo(a);
      <V>   Reflection
          e.g.
             @foo ()
             {
                 return 'hello';
             }
             a = 'foo';
             b = 'a';
             b();

   D. Set
      <I>   Definition
          e.g.
             human {
                 name;
                 age;
                 gender;
                 score;
                 @init (name, age, gender, score)
                 {
                     this.name = name;
                     this.age = age;
                     this.gender = gender;
                     this.score = score;
                 }
                 @getScore ()
                 {
                     return this.score;
                 }
                 @setScore (score)
                 {
                     this.score = score;
                 }
             }
      <II>  Reflection
          e.g.
             alias = 'human';
             inst1 = $alias;
             kid = 'alias';
             inst2 = $kid;

             func_alias1 = 'getScore';
             inst1.func_alias1();
             func_alias2 = 'func_alias1';
             inst1.func_alias2();

             inst2.name = 'getScore';
             inst2.name();
      <III> Instantiation
          e.g.
             John = $human;
      <IV>  add property dynamically in object
          John.parent = ['Jenny', 'Bobby']; //parent not be defined in set.

   E. Reactive Programming
      e.g. normal usage
          @foo (newval, userData)
          {
              @mln_dump(newval);
              @mln_dump(userData);
          }
          name = 'Susan';
          gender = 'female';
          @mln_watch(name, foo, gender);
          name = 'Tom';//Then foo will be called after 'name' assigned.

      e.g. reference
          @foo (&newval, &userData)
          {
              userData = 'male'; //newval => name ('Tom'), userData => gender ('female')
          }
          name = 'Susan';
          gender = 'female';
          @mln_watch(name, foo, gender);
          name = 'Tom';//Then foo will be called after 'name' assigned.
          @mln_dump(gender);


   F. Operator
      Listed by priority from low to high.
      <1> ,
      <2> =  +=  -=  >>=  <<=  *=  /=  |=  &=  ^=  %=
      <3> &&  ||
      <4> &  |  ^
      <5> ==  !=
      <6> >  >=  <  <=
      <7> >>  <<
      <8> +  -
      <9> *  /  %
      <10> ++  --  (suffix)
      <11> []  .
      <12> -  ~  !  &  ++  --  $  ()

      They are not supported by all data types.
      If encountered unsupported operatior, error message would be logged.

   G. Internal Function
      <1> mln_print(var);
      Output var's value. But it cannot output the details of object, function and array.
      <2> mln_msgNew(name);
      Register a message communication item via argument 'name'.
      If it failed, 'false' will be returned. Otherwise, 'true' will be returned.

      <3> mln_msgFree(name);
      Unregister a message communication item via the argument.
      Always return NIL.

      <4> mln_msgRecv(name);
      Receive the data from message communication which is located by 'name'.
      Data will be returned as the return value of this function.

      <5> mln_msgSend(name, var);
      Send the data to the C-side via the message communication item which is located by 'name'.
      'var' is the data which can be:
          a. NIL
          b. INT
          c. REAL
          d. STRING
          e. OBJECT
          f. ARRAY
          g. BOOLEAN
          h. FUNCTION
      If it succeed, 'true' will be returned. Otherwise, 'false' will be returned.

      <6> mln_strcmpSeq(s1, s2);
      Its functionality is the same as 'strcmp()' in C.
      This function will check every byte strictly.
      Both of arguments must be 'string'.

      <7> mln_strcmp(s1, s2);
      Its functionality is the same as 'strcmp()' in C.
      Both of arguments must be 'string'.

      <8> mln_strncmp(s1, s2, n);
      Its functionality is the same as 'strncmp()' in C.
      First two arguments must be 'string', and the last one must be 'int'.

      <9> mln_strstr(s, pattern);
      Its functionality is the same as 'strstr()' in C.
      All of arguments are type 'string'.

      <10> mln_kmp(s, pattern);
      The same as 'mln_strstr()', but implemented in KMP algorithm.

      <11> mln_split(s, offset);
      Return a splited string which starts from 'offset' in 's'.
      'offset' can be negative number.

      <12> mln_slice(s, seps);
      Up to 'seps', 's' will be sliced into several pieces those are placed in an array as the
      return value.
      All of arguments must be 'string' type.
      'seps' is a set of characters used to find the positions to slice.

      <13> mln_strlen(s);
      Return the length of string 's'.

      <14> mln_b2s(bin);
      Memory copy 'bin' into a string.
      Return value is string type.

      <15> mln_s2b(s, type);
      Convert string 's' to be type 'type'.
      'type' is a string which can be "int", "real" and "bool".
      
      <16> MFile
      MFile is the name that a Set to operate file, its melang prototype can be given as,
          set MFile {
              fd;
              errno;
              open(path, op, prio);
              lseek(offset, whence);
              read(nbytes);
              write(data);
              close();
              errmsg();
              size();
          };
      'open' -- 'op' is string type that indicates the operation including Read, Write, Append.
                e.g.   'rwa', 'r', 'w', 'a', 'ra', 'rw'.
                'prio' is an integer that indicates the file access authority, e.g. 0777.
                If open failed, 'false' will be returned, and can get error message via calling
                'errmsg()'.
      'lseek' -- 'offset' is an integer and 'whence' is a string.
                The value of whence includes, 'begin', 'current', 'end'.
                If failed, 'false' will be returned, and can get error message via calling
                'errmsg()'.
      'read' -- 'nbytes' is an integer indicating how many bytes want to read.
                A string will be returned if succeed. Otherwise, 'false' will be returned, and
                error message can be got via calling 'errmsg()'.
      'write' -- 'data' is string that want to be written.
                 'false' will be returned if failed. Otherwise, the number of bytes that written
                 successfully.
      'close' -- close file descriptor.
      'errmsg' -- Get and return error string.
      'size' -- Get the file size in bytes.

      <17> mln_aes(data, key, bits, op);
      'data' -- a string and its length % 16 must equal to 0.
      'key' -- the string type key used to encrypt/decrypt 'data'.
      'bits' -- the bits of 'key'. Key's bit-length must equal or greater than 'bits'.
      'op' -- indicates the operation 'encode' and 'decode' to encrypt and decrypt. It's a string.

      <18> mln_base64(data, op);
      Encode and decode 'data' to be base64 code or the original data.
      'data' -- must be string type.
      'op' -- a string indicating 'encode' or 'decode'.
      Result will be given as return value.

      <19> mln_des(data, key, op);
      Encrypt or decrypt 'data' in DES.
      'data' -- must be string type, and its length % 8 must be 0.
      'key' -- an integer value.
      'op' -- a string value indicating 'encode' or 'decode'.
      Result will be given as return value.

      <20> mln_3des(data, key1, key2, op);
      Encrypt or decrypt 'data' in 3DES.
      'data' -- must be string type, and its length % 8 must be 0.
      'key1', 'key2' -- an integer value.
      'op' -- a string value indicating 'encode' or 'decode'.
      Result will be given as return value.

      <21> mln_prime(base);
      Generate a prime integer greater than 'base'.
      'base' -- must be integer type.
      The return value is an prime number.

      <22> mln_rc4(data, key);
      Encode and decode 'data' in RC4.
      'data' -- must be string type.
      'key' -- must be string type.
      Result will be returned by function.

      <23> mln_md5(data);
      Calculate and return MD5 value.
      'data' can be string type or set 'MFile'.

      <24> mln_sha1(data);
      Calculate and return SHA1 value.
      'data' can be string type or set 'MFile'.

      <25> mln_sha256(data);
      Calculate and return SHA256 value.
      'data' can be string type or set 'MFile'.

      <26> mln_json_encode(array);
      Encode 'array' to be a string. If succeed, result will be returned. Otherwise, 'false'
      will be returned.

      <27> mln_json_decode(s);
      Decode string 's' to be an array. If succeed, result will be returned. Otherwise,
      'false' will be returned.

      <28> mln_matrix_mul(array1, array2);
      Example:
          array1 = ['row': 3, 'col': 2, 'data':[1,0,0,1,1,1]];
          array2 = ['row': 2, 'col': 2, 'data':[1,2,3,4]];
          res_array = mln_matrix_mul(array1, array2);
          nr_row = res_array['row'];
          nr_col = res_array['col'];
          data_array = res_array['data'];
      If failed, 'false' will be returned.

      <29> mln_matrix_inv(array);
      Inverse. Example:
          array = ['row': 2, 'col': 2, 'data':[1,0,1,1]];
          res_array = mln_matrix_inv(array);
          nr_row = res_array['row'];
          nr_col = res_array['col'];
          data_array = res_array['data'];
      If failed, 'false' will be returned.

      <30> mln_size(array);
      Return array's length.

      <31> mln_isInt(var);
      Return a boolean value indicating whether var is an integer.

      <32> mln_isReal(var);
      Return a boolean value indicating whether var is a Real-number.

      <33> mln_isStr(var);
      Return a boolean value indicating whether var is a String.

      <34> mln_isNil(var);
      Return a boolean value indicating whether var is Nil.

      <35> mln_isBool(var);
      Return a boolean value indicating whether var is Boolean.

      <36> mln_isObj(var);
      Return a boolean value indicating whether var is an Object.

      <37> mln_isFunc(var);
      Return a boolean value indicating whether var is an Function.

      <38> mln_isArray(var);
      Return a boolean value indicating whether var is an Array.

      <39> mln_int(var);
      Convert 'var' to be an integer as the return value.

      <40> mln_bool(var);
      Convert 'var' to be a boolean as the return value.

      <41> mln_real(var);
      Convert 'var' to be a real number as the return value.

      <42> mln_str(var);
      Convert 'var' to be a string as the return value.

      <43> mln_obj(var);
      Convert 'var' to be an object as the return value.
      This function only can work on type array of 'var'.
      It will convert an associative array to be an object.
      Key in array will be the name of property in object.

      <44> mln_array(var);
      Convert 'var' to be an array as the return value.
      But for type object, it is not return an array like "[obj]". It will return an associative array whose
      keys and values are the property names and values in the object.

      <45> mln_dump(var);
      Dump all details of 'var' to console and log.

      <46> mln_has(owner, thing);
      Test whether the 'owner' has 'thing'.
      This function is going to be used on array and object.
      To array 'thing' can be any type that melang supports.
      To object 'thing' must be a string.

      <47> mln_keys(array);
      This function will return an array contains all keys in 'array'.

      <48> mln_merge(array1, array2);
      Merge two array into one array.
      If keys in 'array1' are existent in 'array2', the values associated with those keys in 'array2' will be
      in result array.

      <49> mln_watch(var, func, userData);
      This function is provided for supporting Reactive Programming.
      It means that 'var' is being watched by 'func'. If 'var' changed, 'func' will be executed.
      You can find some examples in Section <8. Script language>
      The prototype of 'func' is,
          func (newval, userData);
      Both of func's arguments can be either reference or not. And the second argument 'userData' is identical
      with the third argument in 'mln_watch'.

      <50> mln_unwatch(var);
      Remove watcher from 'var'.

      <51> mln_hex2bin(hex);
      Translate 'hex' to be a binary value indicated by 'hex'.
      Such as mln_hex2bin('48') = 'H'.

      <52> mln_bin2hex(bin);
      Translate 'bin' to be a hex string value indicated by 'bin'.
      Such as mln_bin2hex('H') = '48'.

      <53> mln_bin2int(bin);
      Translate 'bin' to be an integer indicated by 'bin'.

      <54> mln_int2bin(i);
      Translate 'i' to be a binary value indicated by 'i'.

      <55> mln_bin2real(bin);
      Translate 'bin' to be a real-value indicated by 'bin'.

      <56> mln_real2bin(r);
      Translate 'r' to be a binary value indicated by 'r'.

      <57> MMysql
      MMysql is the set operating MySQL database. Its melang prototype is:
          set MMysql {
              fd;
              connect(host, port, dbname, username, password);
              close();
              autocommit(mode);
              commit();
              rollback();
              error();
              errno();
              execute(sql);
          };
      'connect' -- 'port' is an integer, the rest of them are string.
                   If succeed, true will be returned, otherwise false returned.
      'close' -- close mysql connection. Only one return value 'nil'.
      'autocommit' -- control autocommit mode. 'mode' is an boolean.
      'commmit' -- commits the current transaction.
      'rollback' -- rolls back the current transaction.
      'error' -- return error message.
      'errno' -- return error number.
      'execute' -- execute sql.
                   Reading operation returns an array whose every element is also an array
                   to store every record in query results.
                   Writing operation returns a boolean value.

      <58> mln_type(var);
      Return the type of variable. If 'var' is an object, the return value is its set name.

      <59> mln_setProperty(&obj, prop, &val);
      Set object "obj's" property "prop's" value to be 'val'.

      <60> mln_getProperty(&obj, prop);
      Get object "obj's" property "prop's" value.

      <61> mln_eval(val, data, in_string);
      This function will spawn another script task to execute mission indicated by 'val'.
      'val' can be a script path or script code. It depends on 'in_string'.
      'in_string' is a boolean value. If true, 'val' is script code, otherwise, 'val' is file path.
      If 'in_string' is not given or it is not true, that means 'in_string' is false.
      'data' is an injection data for new task. Its type must be one of below:
          int, real, bool, nil, string
      In new task, if we want to fetch this data, we can use variable EVAL_DATA to access it.

      <62> mln_tcpConnect(host, service);
      Connect to a server that indicated by 'host' and 'service'.
      'host' and 'service' must be string.
      If succeed 'true' will be returned, otherwise 'false' returned.

      <63> mln_tcpListen(host, service);
      Set up a TCP listen socket.
      'host' and 'service' must be string.
      If succeed socket file descriptor will be returned, otherwise 'false' returned.

      <64> mln_tcpAccept(listenfd, timeout);
      Accept a TCP connection.
      'listenfd' is created by 'mln_tcpListen'.
      'timeout' is an optional argument. It must be an positive integer or zero. Omit means never timeout.
      If succeed a new socket file descriptor will be returned, otherwise 'false' returned.
      If 'timeout' was given and accept timed out, 'nil' would be returned.

      <65> mln_tcpSend(sockfd, data);
      Send 'data' via 'sockfd'.
      If succeed 'true' will be returned, otherwise 'false' returned.

      <66> mln_tcpRecv(sockfd, timeout);
      Receive data from 'sockfd'.
      'timeout' is an optional argument. It must be an positive integer or zero. Omit means never timeout.
      If succeed received data will be returned. If connection closed by peer, 'true' will be returned.
      Otherwise 'false' returned.
      If 'timeout' was given and accept timed out, 'nil' would be returned.
      Notice: If one script task call 'mln_tcpRecv' to wait for data, but another script task call
      'mln_tcpShutdown' to shutdown 'send' direction, this function will return 'true', because system call
      'recv' will return 0.

      <67> mln_tcpClose(sockfd);
      Close the TCP connection indicated by 'sockfd'.

      <68> mln_tcpShutdown(sockfd, mode);
      Shutdown TCP connection.
      'mode' has two values: 'send' and 'recv'.


   H. Function development
      Following these steps below:
      1. mkdir 'funcname', such as mkdir print
      2. touch two files, mln_lang_funcname.c and mln_lang_funcname.h, like:
         touch mln_lang_print.c mln_lang_print.h
      3. Write the function which is going to be set 'extern' in header file, such as
         int mln_lang_print(mln_lang_ctx_t *ctx)
         {
             ...
         }
      Then you create a new script internal function. More details see .melang/print/.
